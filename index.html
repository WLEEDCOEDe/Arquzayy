<!DOCTYPE html>
<html lang="ar" dir="rtl">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ù…Ù‡Ø§Ù… Ø§Ù„Ø§Ø±Ù‚ÙˆØ§Ø²ÙŠ V6</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <style>
        /* ===== EXISTING ANIMATIONS ===== */
        @keyframes fall {
            to {
                transform: translateY(100vh) rotate(360deg);
                opacity: 0;
            }
        }

        @keyframes bounce {

            0%,
            100% {
                transform: translateY(0);
            }

            50% {
                transform: translateY(-20px);
            }
        }

        @keyframes spin {
            from {
                transform: rotate(0deg);
            }

            to {
                transform: rotate(360deg);
            }
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 0.3;
            }

            50% {
                opacity: 1;
            }
        }

        .animate-bounce {
            animation: bounce 2s infinite;
        }

        .animate-spin {
            animation: spin 3s linear infinite;
        }

        .animate-pulse {
            animation: pulse 2s ease-in-out infinite;
        }

        /* ===== PAGE & TAB SYSTEM ===== */
        .page {
            display: none;
        }

        .page.active {
            display: block;
            animation: fadeIn 0.25s ease-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(8px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .tab-btn {
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .tab-btn:hover:not(.active) {
            transform: translateY(-2px);
            filter: brightness(1.08);
        }

        .tab-btn.active {
            transform: scale(1.05);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
        }

        .tab-btn::after {
            content: '';
            position: absolute;
            inset: 0;
            background: linear-gradient(to top, rgba(255, 255, 255, 0.1), transparent);
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tab-btn:hover::after {
            opacity: 1;
        }

        /* ===== BOARD & CANVAS ===== */
        .board-wrapper {
            position: relative;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.06), 0 4px 16px rgba(0, 0, 0, 0.08);
            transition: box-shadow 0.3s ease;
        }

        .board-wrapper:hover {
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.08), 0 6px 24px rgba(0, 0, 0, 0.12);
        }

        .board-image-object {
            position: absolute;
            cursor: move;
            user-select: none;
            touch-action: none;
            transition: box-shadow 0.2s ease;
        }

        .board-image-object:hover {
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
        }

        .board-image-object.selected {
            outline: 2px solid #a855f7;
            outline-offset: 2px;
            box-shadow: 0 8px 24px rgba(168, 85, 247, 0.3);
        }

        .board-image-object .resize-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #a855f7;
            border-radius: 50%;
            cursor: nwse-resize;
            right: -6px;
            bottom: -6px;
            transition: transform 0.15s ease, background 0.15s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .board-image-object .resize-handle:hover {
            transform: scale(1.2);
            background: #9333ea;
        }

        .board-image-object .rotate-handle {
            position: absolute;
            width: 12px;
            height: 12px;
            background: #7c3aed;
            border-radius: 50%;
            cursor: grab;
            right: 50%;
            top: -18px;
            transform: translateX(50%);
            transition: transform 0.15s ease, background 0.15s ease;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .board-image-object .rotate-handle:hover {
            transform: translateX(50%) scale(1.2);
            background: #6d28d9;
        }

        /* ===== PDF VIEWER ===== */
        .pdf-viewer-container {
            position: relative;
            min-height: 500px;
            box-shadow: inset 0 1px 4px rgba(0, 0, 0, 0.05);
        }

        .pdf-annotation-layer {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .pdf-annotation-layer.active {
            pointer-events: auto;
            cursor: crosshair;
        }

        /* ===== BUTTONS - Micro-interactions ===== */
        button,
        .btn {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
        }

        button:not(:disabled):hover {
            transform: translateY(-1px);
            filter: brightness(1.05);
        }

        button:not(:disabled):active {
            transform: translateY(0) scale(0.98);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Tool buttons active state indicator */
        .tool-btn-active {
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.4), 0 4px 12px rgba(0, 0, 0, 0.15) !important;
            transform: scale(1.02);
        }

        /* ===== INPUTS & SELECTS ===== */
        input[type="text"],
        input[type="password"],
        textarea,
        select {
            transition: all 0.2s ease;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        textarea:focus,
        select:focus {
            box-shadow: 0 0 0 3px rgba(168, 85, 247, 0.15);
        }

        input[type="color"] {
            transition: transform 0.15s ease, box-shadow 0.15s ease;
            cursor: pointer;
        }

        input[type="color"]:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 8px;
            border-radius: 4px;
            background: linear-gradient(to left, #a855f7, #ec4899);
            outline: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid #a855f7;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.15s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.15);
            box-shadow: 0 4px 12px rgba(168, 85, 247, 0.4);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: white;
            border: 3px solid #a855f7;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        /* ===== SECTION CARDS ===== */
        .note-section {
            transition: all 0.25s ease;
        }

        .note-section:hover {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
        }

        /* ===== STICKY NOTES ===== */
        .sticky-note {
            transition: transform 0.15s ease, box-shadow 0.15s ease;
        }

        .sticky-note:hover {
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2) !important;
        }

        /* ===== VISUAL HIERARCHY - Typography ===== */
        h2 {
            letter-spacing: -0.02em;
        }

        h3 {
            letter-spacing: -0.01em;
        }

        .helper-text {
            font-size: 0.8125rem;
            opacity: 0.75;
            line-height: 1.5;
        }

        /* ===== TASK ITEMS ===== */
        .task-item {
            transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .task-item:hover {
            transform: translateY(-2px) scale(1.01);
        }

        /* ===== TOOL GROUP SEPARATOR ===== */
        .tool-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.05);
            border-radius: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .tool-group+.tool-group {
            margin-top: 0.5rem;
        }

        /* ===== SCROLLBAR STYLING ===== */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(168, 85, 247, 0.3);
            border-radius: 4px;
            transition: background 0.2s;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(168, 85, 247, 0.5);
        }

        /* ===== DARK MODE COMPATIBILITY ===== */
        body.dark-mode .board-wrapper {
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2), 0 4px 16px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode .note-section:hover {
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        body.dark-mode input[type="range"] {
            background: linear-gradient(to left, #7c3aed, #a855f7);
        }

        body.dark-mode ::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
        }

        body.dark-mode ::-webkit-scrollbar-thumb {
            background: rgba(168, 85, 247, 0.4);
        }

        body.dark-mode .tool-group {
            background: rgba(168, 85, 247, 0.1);
        }

        /* ===== RESPONSIVE IMPROVEMENTS ===== */
        @media (min-width: 768px) {
            .tool-group {
                padding: 1rem;
            }
        }

        @media (max-width: 768px) {
            .tab-btn {
                padding-left: 1rem;
                padding-right: 1rem;
                font-size: 0.875rem;
            }

            h2 {
                font-size: 1.375rem;
            }

            h3 {
                font-size: 1.0625rem;
            }
        }

        /* ===== FOCUS VISIBLE FOR ACCESSIBILITY ===== */
        button:focus-visible,
        input:focus-visible,
        select:focus-visible,
        textarea:focus-visible {
            outline: 2px solid #a855f7;
            outline-offset: 2px;
        }

        /* ===== LOADING/PROCESSING STATE ===== */
        .processing {
            pointer-events: none;
            opacity: 0.7;
        }

        /* ===== NOTEBOOK SYSTEM ===== */
        .notebook-fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 100;
            display: flex;
            flex-direction: column;
            background: linear-gradient(135deg, #fdf2f8 0%, #f3e8ff 50%, #fdf2f8 100%);
        }

        body.dark-mode .notebook-fullscreen {
            background: linear-gradient(135deg, #1f1f3d 0%, #2d1f4e 50%, #1f1f3d 100%);
        }

        .notebook-toolbar {
            position: sticky;
            top: 0;
            z-index: 110;
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(12px);
            border-bottom: 2px solid rgba(168, 85, 247, 0.2);
            padding: 0.75rem 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
        }

        body.dark-mode .notebook-toolbar {
            background: rgba(30, 30, 50, 0.95);
            border-bottom-color: rgba(168, 85, 247, 0.3);
        }

        .notebook-toolbar-section {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.25rem 0.5rem;
            background: rgba(168, 85, 247, 0.05);
            border-radius: 0.75rem;
        }

        body.dark-mode .notebook-toolbar-section {
            background: rgba(168, 85, 247, 0.15);
        }

        .notebook-toolbar-divider {
            width: 1px;
            height: 32px;
            background: rgba(168, 85, 247, 0.2);
            margin: 0 0.25rem;
        }

        .notebook-main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .notebook-sidebar {
            width: 280px;
            background: rgba(255, 255, 255, 0.9);
            border-left: 2px solid rgba(168, 85, 247, 0.15);
            overflow-y: auto;
            padding: 1rem;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        body.dark-mode .notebook-sidebar {
            background: rgba(30, 30, 50, 0.9);
        }

        .notebook-sidebar.collapsed {
            width: 0;
            padding: 0;
            border: none;
            overflow: hidden;
        }

        .notebook-canvas-area {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            position: relative;
            background: #f8f8f8;
            scroll-behavior: smooth;
        }

        body.dark-mode .notebook-canvas-area {
            background: #1a1a2e;
        }

        .notebook-paper {
            position: relative;
            width: 100%;
            max-width: 900px;
            margin: 0 auto;
            background: white;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.1);
            min-height: 100%;
        }

        body.dark-mode .notebook-paper {
            background: #252540;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3);
        }

        .notebook-page {
            position: relative;
            width: 100%;
            border-bottom: 1px dashed rgba(168, 85, 247, 0.2);
            min-height: 800px;
        }

        .notebook-page:last-child {
            border-bottom: none;
        }

        .notebook-page-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: crosshair;
        }

        .notebook-page-content {
            position: relative;
            z-index: 1;
            pointer-events: none;
        }

        .notebook-page-content img {
            pointer-events: none;
            max-width: 100%;
            display: block;
        }

        /* PDF/Image container for annotation overlay */
        .notebook-inline-file {
            position: relative;
            width: 100%;
            margin: 1rem auto;
            border: 2px solid rgba(168, 85, 247, 0.2);
            border-radius: 0.5rem;
            overflow: visible;
            display: block;
        }

        /* PDF canvas - NO CSS scaling to prevent text distortion */
        .notebook-inline-file canvas.pdf-canvas {
            display: block;
            pointer-events: none;
            /* width and height are set by JavaScript */
        }

        /* Annotation overlay - absolutely positioned OVER the PDF canvas */
        .notebook-annotation-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: auto;
            touch-action: none;
            cursor: crosshair;
            background: transparent;
        }

        /* Delete button for file pages */
        .notebook-page-delete {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: rgba(239, 68, 68, 0.95);
            color: white;
            border: 2px solid white;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            opacity: 1;
            transition: all 0.2s;
            pointer-events: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .notebook-page-delete:hover {
            background: rgba(220, 38, 38, 1);
            transform: scale(1.15);
        }

        /* Old annotation layer style - keep for compatibility */
        .notebook-annotation-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: auto;
        }

        .notebook-page-number {
            position: absolute;
            bottom: 8px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.75rem;
            color: rgba(168, 85, 247, 0.5);
            user-select: none;
        }

        .sidebar-page-item {
            padding: 0.75rem;
            background: rgba(168, 85, 247, 0.05);
            border-radius: 0.5rem;
            cursor: pointer;
            transition: all 0.2s;
            border: 2px solid transparent;
        }

        .sidebar-page-item:hover {
            background: rgba(168, 85, 247, 0.1);
        }

        .sidebar-page-item.active {
            border-color: #a855f7;
            background: rgba(168, 85, 247, 0.15);
        }

        .notebook-add-page-btn {
            padding: 0.75rem;
            border: 2px dashed rgba(168, 85, 247, 0.3);
            border-radius: 0.5rem;
            text-align: center;
            cursor: pointer;
            color: #a855f7;
            font-weight: 600;
            transition: all 0.2s;
        }

        .notebook-add-page-btn:hover {
            background: rgba(168, 85, 247, 0.1);
            border-color: #a855f7;
        }

        /* Notebook tool button states */
        .nb-tool-btn {
            padding: 0.5rem 0.75rem;
            border-radius: 0.5rem;
            font-size: 0.875rem;
            font-weight: 600;
            transition: all 0.15s;
            border: 2px solid transparent;
        }

        .nb-tool-btn:hover {
            transform: translateY(-1px);
        }

        .nb-tool-btn.active {
            box-shadow: 0 0 0 2px rgba(168, 85, 247, 0.5);
            transform: scale(1.02);
        }

        /* Smooth stroke preview */
        .stroke-preview {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            border-radius: 50%;
            border: 2px solid rgba(168, 85, 247, 0.5);
            transition: width 0.1s, height 0.1s;
        }

        /* Page transitions */
        .notebook-page-enter {
            animation: pageEnter 0.3s ease-out;
        }

        @keyframes pageEnter {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Notebook dark mode enhancements */
        body.dark-mode .notebook-sidebar {
            border-left-color: rgba(168, 85, 247, 0.3);
        }

        body.dark-mode .sidebar-page-item {
            background: rgba(168, 85, 247, 0.1);
        }

        body.dark-mode .sidebar-page-item:hover {
            background: rgba(168, 85, 247, 0.2);
        }

        body.dark-mode .sidebar-page-item .text-gray-500 {
            color: #9ca3af;
        }

        body.dark-mode .notebook-add-page-btn {
            color: #c084fc;
            border-color: rgba(168, 85, 247, 0.4);
        }

        body.dark-mode .notebook-sidebar h3 {
            color: #e5e7eb;
        }

        body.dark-mode .notebook-page-number {
            color: rgba(168, 85, 247, 0.7);
        }

        /* Notebook responsive */
        @media (max-width: 768px) {
            .notebook-sidebar {
                position: absolute;
                right: 0;
                top: 0;
                bottom: 0;
                z-index: 105;
                box-shadow: -4px 0 20px rgba(0, 0, 0, 0.2);
            }

            .notebook-sidebar.collapsed {
                transform: translateX(100%);
            }

            .notebook-toolbar {
                padding: 0.5rem;
            }

            .notebook-toolbar-section {
                padding: 0.25rem;
            }

            .nb-tool-btn {
                padding: 0.375rem 0.5rem;
                font-size: 0.75rem;
            }

            .notebook-paper {
                max-width: 100%;
            }
        }

        /* Touch-friendly canvas cursor */
        @media (pointer: coarse) {
            .notebook-page-canvas {
                cursor: default;
            }
        }

        /* ===== NOTEBOOK STICKY NOTES ===== */
        .nb-sticky-note {
            position: absolute;
            min-width: 180px;
            max-width: 280px;
            min-height: 140px;
            padding: 0.75rem;
            border-radius: 0.5rem;
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15), 0 2px 6px rgba(0, 0, 0, 0.1);
            cursor: move;
            z-index: 50;
            transition: box-shadow 0.2s, transform 0.1s;
            user-select: none;
            touch-action: none;
        }

        .nb-sticky-note:hover {
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2), 0 4px 10px rgba(0, 0, 0, 0.15);
            transform: scale(1.02);
        }

        .nb-sticky-note.dragging {
            z-index: 100;
            transform: scale(1.05) rotate(2deg);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.25);
        }

        .nb-sticky-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 0.5rem;
            gap: 0.5rem;
        }

        .nb-sticky-task-badge {
            font-size: 0.65rem;
            padding: 0.2rem 0.5rem;
            background: rgba(168, 85, 247, 0.2);
            color: #7c3aed;
            border-radius: 1rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 120px;
        }

        body.dark-mode .nb-sticky-task-badge {
            background: rgba(168, 85, 247, 0.3);
            color: #c084fc;
        }

        .nb-sticky-delete {
            font-size: 1rem;
            width: 1.5rem;
            height: 1.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            background: rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: background 0.2s;
        }

        .nb-sticky-delete:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        .nb-sticky-content {
            width: 100%;
            min-height: 80px;
            background: transparent;
            border: none;
            resize: none;
            font-size: 0.875rem;
            line-height: 1.5;
            color: inherit;
            outline: none;
        }

        .nb-sticky-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
        }

        .nb-sticky-task-select {
            font-size: 0.7rem;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            border: 1px solid rgba(0, 0, 0, 0.15);
            background: rgba(255, 255, 255, 0.5);
            max-width: 120px;
            cursor: pointer;
        }

        .nb-sticky-date {
            font-size: 0.6rem;
            opacity: 0.6;
        }

        /* Sticky Note Colors */
        .nb-sticky-yellow {
            background: linear-gradient(135deg, #fef08a 0%, #fde047 100%);
            color: #713f12;
        }

        .nb-sticky-pink {
            background: linear-gradient(135deg, #fbcfe8 0%, #f9a8d4 100%);
            color: #831843;
        }

        .nb-sticky-blue {
            background: linear-gradient(135deg, #bfdbfe 0%, #93c5fd 100%);
            color: #1e3a8a;
        }

        .nb-sticky-green {
            background: linear-gradient(135deg, #bbf7d0 0%, #86efac 100%);
            color: #14532d;
        }

        .nb-sticky-purple {
            background: linear-gradient(135deg, #ddd6fe 0%, #c4b5fd 100%);
            color: #4c1d95;
        }

        .nb-sticky-orange {
            background: linear-gradient(135deg, #fed7aa 0%, #fdba74 100%);
            color: #7c2d12;
        }

        /* Notebook Sticky Notes Container */
        .nb-stickies-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 20;
        }

        .nb-stickies-layer .nb-sticky-note {
            pointer-events: auto;
        }

        /* Add Sticky Button in Toolbar */
        .nb-add-sticky-dropdown {
            position: relative;
        }

        .nb-sticky-color-picker {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
            display: none;
            gap: 0.25rem;
            flex-wrap: wrap;
            width: 140px;
            z-index: 200;
        }

        body.dark-mode .nb-sticky-color-picker {
            background: #2d2d4a;
        }

        .nb-add-sticky-dropdown:hover .nb-sticky-color-picker,
        .nb-sticky-color-picker:hover {
            display: flex;
        }

        .nb-sticky-color-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 2px solid transparent;
            cursor: pointer;
            transition: transform 0.15s, border-color 0.15s;
        }

        .nb-sticky-color-btn:hover {
            transform: scale(1.15);
            border-color: #a855f7;
        }

        /* Infinite Scroll Indicators */
        .nb-scroll-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(168, 85, 247, 0.9);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 2rem;
            font-size: 0.75rem;
            font-weight: 600;
            z-index: 120;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
        }

        .nb-scroll-indicator.visible {
            opacity: 1;
        }

        /* Dynamic Canvas Height */
        .notebook-paper.infinite {
            min-height: 200vh;
        }
    </style>
</head>

<body class="bg-gradient-to-br from-pink-100 via-purple-100 to-pink-200 min-h-screen transition-colors duration-300">
    <div style="position: fixed; top: 80px; left: 40px; font-size: 3rem; opacity: 0.3;" class="animate-pulse">â­</div>
    <div style="position: fixed; top: 240px; left: 80px; font-size: 2.5rem; opacity: 0.25; animation-delay: 0.5s;"
        class="animate-pulse">âœ¨</div>
    <div style="position: fixed; bottom: 160px; left: 64px; font-size: 2rem; opacity: 0.2; animation-delay: 1s;"
        class="animate-pulse">ğŸŒŸ</div>
    <div style="position: fixed; top: 128px; right: 40px; font-size: 3rem; opacity: 0.3; animation-delay: 0.3s;"
        class="animate-pulse">â­</div>
    <div style="position: fixed; bottom: 240px; right: 80px; font-size: 2.5rem; opacity: 0.25; animation-delay: 1.2s;"
        class="animate-pulse">âœ¨</div>
    <div style="position: fixed; top: 320px; right: 128px; font-size: 2rem; opacity: 0.2; animation-delay: 0.8s;"
        class="animate-pulse">ğŸŒŸ</div>
    <div style="position: fixed; bottom: 80px; right: 40px; font-size: 4rem; opacity: 0.2; animation-delay: 1s;"
        class="animate-bounce">ğŸ’–</div>
    <div style="position: fixed; top: 160px; left: 50%; font-size: 2.5rem; opacity: 0.2; animation-delay: 0.5s;"
        class="animate-bounce">ğŸŒ¸</div>
    <div id="confettiContainer"></div>

    <div class="max-w-6xl mx-auto p-4 sm:p-8">
        <div class="text-center mb-8 relative">
            <button id="darkModeBtn"
                class="absolute right-0 top-0 p-3 rounded-full bg-gradient-to-r from-purple-500 to-pink-500 text-white hover:scale-110 transition-transform shadow-lg">â˜€ï¸</button>
            <div
                class="absolute left-0 top-0 bg-gradient-to-r from-purple-500 to-pink-500 text-white px-4 py-2 rounded-full text-sm font-bold shadow-lg">
                V6 âœ¨ </div>

            <div class="mb-6 relative inline-block">
                <div style="position: absolute; top: -8px; right: -8px; font-size: 2.5rem;" class="animate-spin">âœ¨</div>
                <div style="position: absolute; top: -8px; left: -8px; font-size: 2.5rem; animation-direction: reverse;"
                    class="animate-spin">â­</div>
                <div class="bg-white/40 backdrop-blur-sm rounded-full p-6 shadow-2xl border-4 border-pink-300"
                    style="animation: bounce 2s infinite;">
                    <svg width="120" height="120" viewBox="0 0 120 120">
                        <ellipse cx="60" cy="65" rx="45" ry="42" fill="#FFFFFF" />
                        <ellipse cx="30" cy="30" rx="18" ry="22" fill="#FFFFFF" />
                        <ellipse cx="30" cy="32" rx="12" ry="15" fill="#FFB6C1" />
                        <ellipse cx="90" cy="30" rx="18" ry="22" fill="#FFFFFF" />
                        <ellipse cx="90" cy="32" rx="12" ry="15" fill="#FFB6C1" />
                        <ellipse cx="85" cy="25" rx="15" ry="12" fill="#FF1493" />
                        <ellipse cx="105" cy="25" rx="15" ry="12" fill="#FF1493" />
                        <circle cx="95" cy="25" r="8" fill="#FF69B4" />
                        <circle cx="95" cy="25" r="4" fill="#FFB6C1" />
                        <ellipse cx="45" cy="60" rx="4" ry="8" fill="#000000" />
                        <ellipse cx="75" cy="60" rx="4" ry="8" fill="#000000" />
                        <ellipse cx="60" cy="70" rx="3" ry="4" fill="#FFD700" />
                        <line x1="25" y1="68" x2="42" y2="68" stroke="#000000" stroke-width="1.5" />
                        <line x1="25" y1="73" x2="42" y2="71" stroke="#000000" stroke-width="1.5" />
                        <line x1="25" y1="78" x2="42" y2="75" stroke="#000000" stroke-width="1.5" />
                        <line x1="78" y1="68" x2="95" y2="68" stroke="#000000" stroke-width="1.5" />
                        <line x1="78" y1="71" x2="95" y2="73" stroke="#000000" stroke-width="1.5" />
                        <line x1="78" y1="75" x2="95" y2="78" stroke="#000000" stroke-width="1.5" />
                    </svg>
                </div>
                <div style="position: absolute; bottom: -8px; right: -8px; font-size: 2.5rem;" class="animate-pulse">ğŸ’–
                </div>
                <div style="position: absolute; bottom: -8px; left: -8px; font-size: 2.5rem; animation-delay: 0.5s;"
                    class="animate-pulse">ğŸŒ¸</div>
            </div>

            <div id="rewardMessage" style="display: none;" class="mb-6 animate-pulse">
                <div class="bg-gradient-to-r from-yellow-400 via-pink-500 to-purple-600 text-white rounded-3xl px-8 py-6 shadow-2xl inline-block"
                    style="transform: scale(1.1);">
                    <div class="text-6xl mb-3">ğŸ‰ ğŸ† </div>
                    <h2 class="text-3xl font-bold mb-2">ÙƒÙÙˆ ÙŠØ§Ù…Ù„ÙƒØ§ </h2>
                </div>
            </div>

            <div class="inline-block mb-4">
                <div
                    class="bg-gradient-to-r from-pink-500 via-purple-500 to-pink-600 text-white rounded-3xl px-8 py-4 shadow-2xl hover:scale-105 transition-transform border-4 border-white/30">
                    <h1 class="text-4xl font-bold mb-2 flex items-center justify-center gap-3"><span>ğŸ€</span> Ø§Ù„Ù…Ù‡Ø§Ù…
                        Ø§Ù„ÙŠÙˆÙ…ÙŠØ© <span>ğŸ€</span></h1>
                    <div class="flex items-center justify-center gap-2 text-sm opacity-90"><span>ğŸ“…</span><span
                            id="currentDate"></span></div>
                </div>
            </div>

            <div class="flex justify-center mb-8 overflow-x-auto pb-2">
                <div class="inline-flex rounded-2xl bg-white/80 backdrop-blur-sm p-1.5 shadow-lg gap-1">
                    <button id="todayTab"
                        class="tab-btn active px-5 md:px-6 py-3 rounded-xl font-bold bg-gradient-to-r from-pink-500 to-purple-500 text-white text-sm md:text-base">Ø§Ù„ÙŠÙˆÙ…
                        ğŸ“‹</button>
                    <button id="calendarTab"
                        class="tab-btn px-5 md:px-6 py-3 rounded-xl font-bold bg-gradient-to-r from-purple-400 to-blue-400 text-white text-sm md:text-base">Ø§Ù„Ø¬Ø¯ÙˆÙ„
                        ğŸ—“ï¸</button>
                    <button id="historyTab"
                        class="tab-btn px-5 md:px-6 py-3 rounded-xl font-bold bg-gradient-to-r from-blue-500 to-green-500 text-white text-sm md:text-base">Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²
                        ğŸ“Š</button>
                    <button id="notesTab"
                        class="tab-btn px-5 md:px-6 py-3 rounded-xl font-bold bg-gradient-to-r from-green-500 to-teal-500 text-white text-sm md:text-base">Ù…Ù„Ø§Ø­Ø¸Ø§Øª
                        ğŸ“</button>
                </div>
            </div>

            <div id="progressContainer"
                class="bg-white/90 backdrop-blur-lg rounded-2xl p-5 md:p-6 shadow-xl border border-purple-200">
                <div class="flex justify-between items-center mb-3">
                    <span class="text-gray-900 font-semibold text-sm md:text-base">Ø§Ù„ØªÙ‚Ø¯Ù… Ø§Ù„ÙŠÙˆÙ…ÙŠ</span>
                    <span class="text-gray-600 font-bold text-sm md:text-base" id="progressText">0 / 0</span>
                </div>
                <div class="w-full h-3 md:h-4 bg-gray-200 rounded-full overflow-hidden shadow-inner">
                    <div id="progressBar"
                        class="h-full bg-gradient-to-r from-purple-500 via-pink-500 to-blue-500 transition-all duration-500 relative rounded-full"
                        style="width: 0%">
                        <div class="absolute inset-0 bg-white/30 animate-pulse rounded-full"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="todayPage" class="page active">
            <div id="inputContainer"
                class="bg-white/90 backdrop-blur-lg rounded-2xl p-5 md:p-6 mb-6 shadow-xl border border-purple-200">
                <div class="flex flex-col gap-4">
                    <input type="text" id="taskInput" placeholder="Ø£Ø¶Ù Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©..."
                        class="flex-1 px-5 py-4 rounded-xl border-2 bg-white border-purple-300 text-gray-900 focus:border-purple-500 focus:outline-none transition-all text-base md:text-lg">
                    <div class="flex flex-col sm:flex-row gap-3">
                        <select id="prioritySelect"
                            class="px-4 py-3.5 rounded-xl border-2 bg-white border-purple-300 text-gray-900 focus:border-purple-500 focus:outline-none transition-all flex-1 text-sm md:text-base">
                            <option value="low">Ø£ÙˆÙ„ÙˆÙŠØ© Ù…Ù†Ø®ÙØ¶Ø©</option>
                            <option value="medium" selected>Ø£ÙˆÙ„ÙˆÙŠØ© Ù…ØªÙˆØ³Ø·Ø©</option>
                            <option value="high">Ø£ÙˆÙ„ÙˆÙŠØ© Ø¹Ø§Ù„ÙŠØ©</option>
                        </select>
                        <select id="daySelect"
                            class="px-4 py-3.5 rounded-xl border-2 bg-white border-purple-300 text-gray-900 focus:border-purple-500 focus:outline-none transition-all flex-1 text-sm md:text-base">
                            <option value="today">Ø§Ù„ÙŠÙˆÙ…</option>
                            <option value="tomorrow">ØºØ¯Ø§Ù‹</option>
                            <option value="day3">Ø¨Ø¹Ø¯ Ø¨ÙƒØ±Ù‡</option>
                            <option value="day4">Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø±Ø§Ø¨Ø¹</option>
                            <option value="day5">Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø®Ø§Ù…Ø³</option>
                        </select>
                        <button id="addBtn"
                            class="bg-gradient-to-r from-purple-600 to-pink-600 text-white px-6 md:px-8 py-3.5 rounded-xl font-bold shadow-lg flex-1 text-sm md:text-base">â•
                            Ø¥Ø¶Ø§ÙØ©</button>
                    </div>
                </div>
            </div>
            <div id="tasksList" class="space-y-4"></div>
        </div>

        <div id="calendarPage" class="page">
            <div class="bg-white/90 backdrop-blur-lg rounded-2xl p-6 mb-6 shadow-xl border border-purple-200">
                <h2 class="text-2xl font-bold mb-6 text-center text-gray-800">ğŸ—“ï¸ Ø¬Ø¯ÙˆÙ„ Ø§Ù„Ù…Ù‡Ø§Ù… Ø§Ù„Ù…Ø³ØªÙ‚Ø¨Ù„ÙŠØ©</h2>
                <div id="dayCards" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-8"></div>
                <div class="text-center text-gray-600">
                    <p class="mb-2">ğŸ“Œ ÙŠÙ…ÙƒÙ†Ùƒ Ø³Ø­Ø¨ Ø§Ù„Ù…Ù‡Ø§Ù… Ø¨ÙŠÙ† Ø§Ù„Ø£ÙŠØ§Ù… Ù„ØªØºÙŠÙŠØ± Ù…ÙˆØ¹Ø¯Ù‡Ø§</p>
                    <p class="text-sm">Ø§Ø³Ø­Ø¨ Ø§Ù„Ù…Ù‡Ù…Ø© Ø¥Ù„Ù‰ Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ù…Ø·Ù„ÙˆØ¨ Ù„ØªØºÙŠÙŠØ± ØªØ§Ø±ÙŠØ®Ù‡Ø§</p>
                </div>
            </div>
            <div id="calendarTasks" class="space-y-6"></div>
        </div>

        <div id="historyPage" class="page">
            <div class="bg-white/90 backdrop-blur-lg rounded-2xl p-6 mb-6 shadow-xl border border-purple-200">
                <h2 class="text-2xl font-bold mb-6 text-center text-gray-800">ğŸ“Š Ø³Ø¬Ù„ Ø§Ù„Ø¥Ù†Ø¬Ø§Ø²</h2>
                <div class="flex flex-wrap justify-center gap-3 mb-8">
                    <button id="showAllHistory"
                        class="px-5 py-2.5 rounded-xl bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold shadow-md">Ø§Ù„ÙƒÙ„</button>
                    <button id="showWeekHistory"
                        class="px-5 py-2.5 rounded-xl bg-gradient-to-r from-blue-500 to-purple-500 text-white font-bold shadow-md">Ø¢Ø®Ø±
                        Ø£Ø³Ø¨ÙˆØ¹</button>
                    <button id="showMonthHistory"
                        class="px-5 py-2.5 rounded-xl bg-gradient-to-r from-green-500 to-blue-500 text-white font-bold shadow-md">Ø¢Ø®Ø±
                        Ø´Ù‡Ø±</button>
                </div>
                <div id="historyStats" class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8"></div>
                <div id="historyList" class="space-y-4"></div>
            </div>
        </div>

        <div id="notesPage" class="page">
            <!-- Notebook Entry View -->
            <div id="notebookEntry"
                class="bg-white/90 backdrop-blur-lg rounded-2xl p-6 md:p-8 mb-6 shadow-xl border border-purple-200">
                <h2 class="text-2xl font-bold mb-8 text-center text-gray-800">ğŸ“ Ø¯ÙØªØ± Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª</h2>

                <!-- Task Selector & Lock -->
                <div
                    class="flex flex-col md:flex-row gap-4 mb-8 p-4 bg-purple-50/50 rounded-xl border border-purple-100">
                    <div class="flex-1">
                        <label class="block mb-2 text-gray-700 font-semibold text-sm">ğŸ”— Ø±Ø¨Ø· Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© Ø¨Ù…Ù‡Ù…Ø©:</label>
                        <select id="noteTaskSelector"
                            class="w-full px-4 py-3 rounded-xl border-2 bg-white border-purple-300 text-gray-900 focus:border-purple-500 focus:outline-none transition-all">
                            <option value="global">Ù…Ù„Ø§Ø­Ø¸Ø© Ø¹Ø§Ù…Ø©</option>
                        </select>
                    </div>
                    <div class="flex items-end gap-3">
                        <button id="lockNoteBtn"
                            class="px-4 py-3 rounded-xl bg-gradient-to-r from-red-500 to-pink-500 text-white font-bold transition-all whitespace-nowrap">ğŸ”’
                            Ù‚ÙÙ„</button>
                        <span id="noteLockStatus" class="text-sm text-gray-600 pb-1"></span>
                    </div>
                </div>

                <!-- Open Notebook Button -->
                <div id="noteContent" class="text-center">
                    <button id="openNotebookBtn"
                        class="px-8 py-4 rounded-2xl bg-gradient-to-r from-purple-600 to-pink-600 text-white font-bold text-xl shadow-lg hover:shadow-xl transition-all hover:scale-105">
                        ğŸ“– ÙØªØ­ Ø¯ÙØªØ± Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª
                    </button>
                    <p class="mt-4 text-gray-600 text-sm">Ø¯ÙØªØ± Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ø§Ø­ØªØ±Ø§ÙÙŠ Ù…Ø¹ ÙƒØªØ§Ø¨Ø© ÙŠØ¯ÙˆÙŠØ© ÙˆØªØ¹Ù„ÙŠÙ‚Ø§Øª Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„ÙØ§Øª</p>
                </div>
            </div>

            <!-- Password Modal -->
            <div id="passwordModal"
                class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center">
                <div class="bg-white rounded-2xl p-6 shadow-2xl max-w-md w-full mx-4">
                    <h3 class="text-xl font-bold mb-4 text-gray-800">ğŸ” Ø¥Ø¯Ø®Ø§Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±</h3>
                    <input type="password" id="passwordInput" placeholder="Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ±..."
                        class="w-full px-4 py-3 rounded-xl border-2 border-purple-300 mb-4 focus:border-purple-500 focus:outline-none">
                    <div class="flex gap-3">
                        <button id="passwordSubmit"
                            class="flex-1 px-4 py-2 rounded-lg bg-gradient-to-r from-purple-500 to-pink-500 text-white font-bold">ØªØ£ÙƒÙŠØ¯</button>
                        <button id="passwordCancel"
                            class="flex-1 px-4 py-2 rounded-lg bg-gray-300 text-gray-800 font-bold">Ø¥Ù„ØºØ§Ø¡</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Full-Screen Notebook (Hidden by default) -->
        <div id="notebookFullscreen" class="notebook-fullscreen hidden">
            <!-- Sticky Toolbar -->
            <div class="notebook-toolbar">
                <button id="closeNotebookBtn"
                    class="nb-tool-btn bg-gradient-to-r from-gray-500 to-gray-600 text-white">âœ• Ø¥ØºÙ„Ø§Ù‚</button>

                <div class="notebook-toolbar-divider"></div>

                <!-- Pen Tools -->
                <div class="notebook-toolbar-section">
                    <input type="color" id="nbPenColor" value="#000000"
                        class="w-10 h-8 rounded border-2 border-purple-300 cursor-pointer" title="Ù„ÙˆÙ† Ø§Ù„Ù‚Ù„Ù…">
                    <input type="range" id="nbPenThickness" min="1" max="30" value="3" class="w-24" title="Ø³Ù…Ø§ÙƒØ© Ø§Ù„Ù‚Ù„Ù…">
                    <span id="nbThicknessValue" class="text-xs font-bold w-8">3px</span>
                </div>

                <div class="notebook-toolbar-section">
                    <button id="nbPenBtn"
                        class="nb-tool-btn bg-gradient-to-r from-blue-500 to-purple-500 text-white active">âœï¸
                        Ù‚Ù„Ù…</button>
                    <button id="nbHighlighterBtn"
                        class="nb-tool-btn bg-gradient-to-r from-amber-400 to-yellow-500 text-white">ğŸ–ï¸ ØªÙ…ÙŠÙŠØ²</button>
                    <button id="nbEraserBtn"
                        class="nb-tool-btn bg-gradient-to-r from-gray-500 to-gray-600 text-white">ğŸ§¹ Ù…Ù…Ø­Ø§Ø©</button>
                </div>

                <div class="notebook-toolbar-divider"></div>

                <div class="notebook-toolbar-section">
                    <button id="nbUndoBtn"
                        class="nb-tool-btn bg-gradient-to-r from-yellow-500 to-orange-500 text-white">â†¶</button>
                    <button id="nbRedoBtn"
                        class="nb-tool-btn bg-gradient-to-r from-green-500 to-teal-500 text-white">â†·</button>
                </div>

                <div class="notebook-toolbar-divider"></div>

                <div class="notebook-toolbar-section">
                    <input type="file" id="nbFileInput" accept="image/*,.pdf" class="hidden">
                    <button id="nbAddFileBtn"
                        class="nb-tool-btn bg-gradient-to-r from-purple-500 to-pink-500 text-white">ğŸ“ Ù…Ù„Ù</button>
                    <button id="nbAddPageBtn"
                        class="nb-tool-btn bg-gradient-to-r from-green-500 to-emerald-500 text-white">â• ØµÙØ­Ø©</button>

                    <!-- Sticky Notes Button with Color Picker -->
                    <div class="nb-add-sticky-dropdown">
                        <button id="nbAddStickyBtn"
                            class="nb-tool-btn bg-gradient-to-r from-yellow-400 to-amber-500 text-white">ğŸ“Œ
                            Ù…Ù„Ø§Ø­Ø¸Ø©</button>
                        <div class="nb-sticky-color-picker">
                            <button type="button" class="nb-sticky-color-btn" data-color="yellow"
                                style="background: linear-gradient(135deg, #fef08a, #fde047);" title="Ø£ØµÙØ±"></button>
                            <button type="button" class="nb-sticky-color-btn" data-color="pink"
                                style="background: linear-gradient(135deg, #fbcfe8, #f9a8d4);" title="ÙˆØ±Ø¯ÙŠ"></button>
                            <button type="button" class="nb-sticky-color-btn" data-color="blue"
                                style="background: linear-gradient(135deg, #bfdbfe, #93c5fd);" title="Ø£Ø²Ø±Ù‚"></button>
                            <button type="button" class="nb-sticky-color-btn" data-color="green"
                                style="background: linear-gradient(135deg, #bbf7d0, #86efac);" title="Ø£Ø®Ø¶Ø±"></button>
                            <button type="button" class="nb-sticky-color-btn" data-color="purple"
                                style="background: linear-gradient(135deg, #ddd6fe, #c4b5fd);" title="Ø¨Ù†ÙØ³Ø¬ÙŠ"></button>
                            <button type="button" class="nb-sticky-color-btn" data-color="orange"
                                style="background: linear-gradient(135deg, #fed7aa, #fdba74);" title="Ø¨Ø±ØªÙ‚Ø§Ù„ÙŠ"></button>
                        </div>
                    </div>
                </div>

                <div class="flex-1"></div>

                <div class="notebook-toolbar-section">
                    <button id="nbExportBtn"
                        class="nb-tool-btn bg-gradient-to-r from-blue-500 to-cyan-500 text-white">ğŸ’¾ ØªØµØ¯ÙŠØ±</button>
                    <button id="nbToggleSidebar" class="nb-tool-btn bg-gray-200 text-gray-800">â˜°</button>
                </div>
            </div>

            <!-- Main Content Area -->
            <div class="notebook-main">
                <!-- Canvas Area (Infinite Scroll) -->
                <div id="notebookCanvasArea" class="notebook-canvas-area">
                    <div id="notebookPaper" class="notebook-paper infinite">
                        <!-- Stickies Layer (for movable sticky notes) -->
                        <div id="nbStickiesLayer" class="nb-stickies-layer">
                            <!-- Sticky notes will be dynamically inserted here -->
                        </div>
                        <!-- Pages will be dynamically inserted here -->
                    </div>
                    <!-- Scroll Indicator -->
                    <div id="nbScrollIndicator" class="nb-scroll-indicator"></div>
                </div>

                <!-- Sidebar (Pages & Attachments) -->
                <div id="notebookSidebar" class="notebook-sidebar">
                    <h3 class="font-bold text-gray-800 mb-2">ğŸ“„ Ø§Ù„ØµÙØ­Ø§Øª</h3>
                    <div id="sidebarPagesList" class="space-y-2 mb-4">
                        <!-- Page thumbnails -->
                    </div>
                    <div id="nbAddPageSidebar" class="notebook-add-page-btn">â• Ø¥Ø¶Ø§ÙØ© ØµÙØ­Ø©</div>

                    <div class="border-t border-purple-200 my-4"></div>

                    <h3 class="font-bold text-gray-800 mb-2">ğŸ“ Ø§Ù„Ù…Ø±ÙÙ‚Ø§Øª</h3>
                    <div id="sidebarAttachments" class="space-y-2">
                        <!-- Attachment list -->
                    </div>

                    <div class="border-t border-purple-200 my-4"></div>

                    <h3 class="font-bold text-gray-800 mb-2">ğŸ“š History Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø§Øª</h3>
                    <div id="sidebarNotesHistory" class="space-y-2" style="max-height: 300px; overflow-y: auto;">
                        <!-- Notes history will be dynamically inserted here -->
                    </div>
                </div>
            </div>
        </div>

        <!-- Legacy elements for compatibility (hidden) -->
        <div id="legacyNoteElements" class="hidden">
            <canvas id="drawingCanvas"></canvas>
            <div id="boardWrapper"></div>
            <textarea id="textNotes"></textarea>
            <input type="color" id="textColor" value="#000000">
            <input type="color" id="penColor" value="#000000">
            <input type="range" id="penThickness" min="1" max="20" value="5">
            <span id="thicknessValue">5px</span>
            <button id="penBtn"></button>
            <button id="highlighterBtn"></button>
            <button id="eraserBtn"></button>
            <button id="undoBtn"></button>
            <button id="redoBtn"></button>
            <button id="clearCanvasBtn"></button>
            <span id="canvasLastModified"></span>
            <span id="textLastModified"></span>
            <input type="color" id="stickyColor" value="#ffeb3b">
            <button id="addStickyBtn"></button>
            <div id="stickyNotesContainer"></div>
            <input type="file" id="fileInput" accept="image/*,.pdf">
            <button id="attachFileBtn"></button>
            <div id="attachmentsContainer"></div>
            <div id="pdfViewerSection">
                <button id="pdfPrevPage"></button>
                <button id="pdfNextPage"></button>
                <span id="pdfPageIndicator"></span>
                <button id="pdfZoomOut"></button>
                <button id="pdfZoomIn"></button>
                <button id="pdfAnnotateBtn"></button>
                <canvas id="pdfCanvas"></canvas>
                <canvas id="pdfAnnotationCanvas"></canvas>
            </div>
            <button id="exportJSONBtn"></button>
            <button id="exportPNGBtn"></button>
            <input type="file" id="importFileInput" accept=".json,.png">
            <button id="importBtn"></button>
        </div>
    </div>

    <script>
        let tasks = [];
        let darkMode = false;
        let currentPage = 'today';
        let activeTimers = {};

        const taskInput = document.getElementById('taskInput');
        const prioritySelect = document.getElementById('prioritySelect');
        const daySelect = document.getElementById('daySelect');
        const addBtn = document.getElementById('addBtn');
        const tasksList = document.getElementById('tasksList');
        const progressBar = document.getElementById('progressBar');
        const progressText = document.getElementById('progressText');
        const progressContainer = document.getElementById('progressContainer');
        const inputContainer = document.getElementById('inputContainer');
        const rewardMessage = document.getElementById('rewardMessage');
        const currentDate = document.getElementById('currentDate');
        const darkModeBtn = document.getElementById('darkModeBtn');
        const todayPage = document.getElementById('todayPage');
        const calendarPage = document.getElementById('calendarPage');
        const historyPage = document.getElementById('historyPage');
        const notesPage = document.getElementById('notesPage');

        // Notes System Elements
        const noteTaskSelector = document.getElementById('noteTaskSelector');
        const noteContent = document.getElementById('noteContent');
        const lockNoteBtn = document.getElementById('lockNoteBtn');
        const noteLockStatus = document.getElementById('noteLockStatus');
        const passwordModal = document.getElementById('passwordModal');
        const passwordInput = document.getElementById('passwordInput');
        const passwordSubmit = document.getElementById('passwordSubmit');
        const passwordCancel = document.getElementById('passwordCancel');
        const drawingCanvas = document.getElementById('drawingCanvas');
        const penColor = document.getElementById('penColor');
        const penThickness = document.getElementById('penThickness');
        const thicknessValue = document.getElementById('thicknessValue');
        const highlighterBtn = document.getElementById('highlighterBtn');
        const eraserBtn = document.getElementById('eraserBtn');
        const penBtn = document.getElementById('penBtn');
        const undoBtn = document.getElementById('undoBtn');
        const boardWrapper = document.getElementById('boardWrapper');
        const pdfViewerSection = document.getElementById('pdfViewerSection');
        const pdfViewerContainer = document.getElementById('pdfViewerContainer');
        const pdfCanvas = document.getElementById('pdfCanvas');
        const pdfAnnotationCanvas = document.getElementById('pdfAnnotationCanvas');
        const pdfPrevPage = document.getElementById('pdfPrevPage');
        const pdfNextPage = document.getElementById('pdfNextPage');
        const pdfPageIndicator = document.getElementById('pdfPageIndicator');
        const pdfZoomIn = document.getElementById('pdfZoomIn');
        const pdfZoomOut = document.getElementById('pdfZoomOut');
        const pdfAnnotateBtn = document.getElementById('pdfAnnotateBtn');
        const redoBtn = document.getElementById('redoBtn');
        const clearCanvasBtn = document.getElementById('clearCanvasBtn');
        const canvasLastModified = document.getElementById('canvasLastModified');
        const textNotes = document.getElementById('textNotes');
        const textColor = document.getElementById('textColor');
        const textLastModified = document.getElementById('textLastModified');
        const stickyColor = document.getElementById('stickyColor');
        const addStickyBtn = document.getElementById('addStickyBtn');
        const stickyNotesContainer = document.getElementById('stickyNotesContainer');
        const fileInput = document.getElementById('fileInput');
        const attachFileBtn = document.getElementById('attachFileBtn');
        const attachmentsContainer = document.getElementById('attachmentsContainer');
        const exportJSONBtn = document.getElementById('exportJSONBtn');
        const exportPNGBtn = document.getElementById('exportPNGBtn');
        const importFileInput = document.getElementById('importFileInput');
        const importBtn = document.getElementById('importBtn');
        const todayTab = document.getElementById('todayTab');
        const calendarTab = document.getElementById('calendarTab');
        const historyTab = document.getElementById('historyTab');
        const notesTab = document.getElementById('notesTab');
        const showAllHistory = document.getElementById('showAllHistory');
        const showWeekHistory = document.getElementById('showWeekHistory');
        const showMonthHistory = document.getElementById('showMonthHistory');

        // Notes System Variables
        let notes = {};
        let currentNoteId = 'global';
        let boardStrokes = [];
        let boardStrokesRedoStack = [];
        let currentStroke = null;
        let isDrawing = false;
        let isEraser = false;
        let isHighlighter = false;
        let currentTool = 'pen';
        let stickyNoteZIndex = 1000;
        let pdfDoc = null;
        let pdfCurrentPage = 1;
        let pdfTotalPages = 0;
        let pdfScale = 1.2;
        let pdfAnnotating = false;
        let currentPdfAttachmentIndex = -1;
        let pdfAnnotationStrokes = [];
        let pdfAnnotationCurrentStroke = null;

        currentDate.textContent = new Date().toLocaleDateString('ar-SA', {
            weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
        });

        function formatTime(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = seconds % 60;
            if (hours > 0) return `${hours}Ø³ ${minutes}Ø¯`;
            if (minutes > 0) return `${minutes}Ø¯ ${secs}Ø«`;
            return `${secs}Ø«`;
        }

        function getRelativeDate(dateString) {
            const date = new Date(dateString);
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            const weekAgo = new Date(today);
            weekAgo.setDate(weekAgo.getDate() - 7);
            date.setHours(0, 0, 0, 0);
            if (date.getTime() === today.getTime()) return 'Ø§Ù„ÙŠÙˆÙ…';
            if (date.getTime() === yesterday.getTime()) return 'Ø£Ù…Ø³';
            if (date >= weekAgo) return 'Ø¢Ø®Ø± Ø£Ø³Ø¨ÙˆØ¹';
            return 'Ø³Ø§Ø¨Ù‚Ø§Ù‹';
        }

        function formatDate(date) {
            return date.toLocaleDateString('ar-SA', {
                weekday: 'long', year: 'numeric', month: 'long', day: 'numeric'
            });
        }

        function getDateForDay(dayOffset) {
            const date = new Date();
            date.setDate(date.getDate() + dayOffset);
            return formatDate(date);
        }

        function loadTasks() {
            const saved = localStorage.getItem('taskAppData');
            if (saved) {
                const data = JSON.parse(saved);
                tasks = data.tasks || [];
                darkMode = data.darkMode || false;
                applyDarkMode();
            }
        }

        function saveTasks() {
            const data = { tasks, darkMode, lastUpdated: new Date().toISOString() };
            localStorage.setItem('taskAppData', JSON.stringify(data));
        }

        function applyDarkMode() {
            if (darkMode) {
                document.body.className = 'dark-mode bg-gradient-to-br from-gray-900 via-purple-900 to-gray-900 min-h-screen transition-colors duration-300';
                darkModeBtn.textContent = 'ğŸŒ™';
                progressContainer.className = 'bg-gray-800/90 backdrop-blur-lg rounded-2xl p-6 shadow-xl border border-purple-700';
                inputContainer.className = 'bg-gray-800/90 backdrop-blur-lg rounded-2xl p-6 mb-6 shadow-xl border border-purple-700';
                taskInput.className = 'flex-1 px-5 py-4 rounded-xl border-2 bg-gray-700 border-purple-500 text-white focus:border-purple-400 focus:outline-none transition-all text-lg';
                prioritySelect.className = 'px-4 py-4 rounded-xl border-2 bg-gray-700 border-purple-500 text-white focus:border-purple-400 focus:outline-none transition-all flex-1';
                daySelect.className = 'px-4 py-4 rounded-xl border-2 bg-gray-700 border-purple-500 text-white focus:border-purple-400 focus:outline-none transition-all flex-1';
                const labels = progressContainer.querySelectorAll('span');
                if (labels[0]) labels[0].className = 'text-gray-200 font-semibold';
                if (labels[1]) labels[1].className = 'text-gray-400 font-bold';

                // Notes page dark mode
                if (notesPage) {
                    const notesContainer = notesPage.querySelector('.bg-white\\/90');
                    if (notesContainer) notesContainer.className = 'bg-gray-800/90 backdrop-blur-lg rounded-2xl p-6 shadow-xl border border-purple-700';
                    // Notebook entry
                    if (notebookEntry) {
                        notebookEntry.className = 'bg-gray-800/90 backdrop-blur-lg rounded-2xl p-6 md:p-8 mb-6 shadow-xl border border-purple-700';
                        const nbEntryLabels = notebookEntry.querySelectorAll('h2, h3, label, p');
                        nbEntryLabels.forEach(el => {
                            el.className = el.className.replace('text-gray-800', 'text-gray-200').replace('text-gray-700', 'text-gray-300').replace('text-gray-600', 'text-gray-400');
                        });
                    }
                    const noteSelectors = notesPage.querySelectorAll('select, input[type="text"], input[type="password"], textarea');
                    noteSelectors.forEach(el => {
                        if (el.id !== 'penColor' && el.id !== 'textColor' && el.id !== 'stickyColor') {
                            let className = el.className;
                            className = className.replace(/bg-white/g, 'bg-gray-700');
                            className = className.replace(/text-gray-900/g, 'text-white');
                            className = className.replace(/border-purple-300/g, 'border-purple-500');
                            el.className = className;
                        }
                    });
                    const noteLabels = notesPage.querySelectorAll('label, h2, h3');
                    noteLabels.forEach(el => {
                        el.className = el.className.replace('text-gray-800', 'text-gray-200').replace('text-gray-700', 'text-gray-300');
                    });
                    const noteSections = notesPage.querySelectorAll('.bg-gray-50');
                    noteSections.forEach(el => el.className = 'bg-gray-700/50 rounded-xl p-4 border-2 border-purple-600');
                    const stickyTextareas = notesPage.querySelectorAll('.sticky-note textarea');
                    stickyTextareas.forEach(el => el.className += ' text-white');
                    const passwordModalContent = passwordModal.querySelector('.bg-white');
                    if (passwordModalContent) passwordModalContent.className = 'bg-gray-800 rounded-2xl p-6 shadow-2xl max-w-md w-full mx-4';
                    const passwordModalInputs = passwordModal.querySelectorAll('input, button');
                    passwordModalInputs.forEach(el => {
                        if (el.type === 'password' || el.tagName === 'INPUT') {
                            el.className = el.className.replace('bg-white', 'bg-gray-700').replace('text-gray-900', 'text-white').replace('border-purple-300', 'border-purple-500');
                        }
                    });
                }
            } else {
                document.body.className = 'bg-gradient-to-br from-pink-100 via-purple-100 to-pink-200 min-h-screen transition-colors duration-300';
                darkModeBtn.textContent = 'â˜€ï¸';
                progressContainer.className = 'bg-white/90 backdrop-blur-lg rounded-2xl p-6 shadow-xl border border-purple-200';
                inputContainer.className = 'bg-white/90 backdrop-blur-lg rounded-2xl p-6 mb-6 shadow-xl border border-purple-200';
                taskInput.className = 'flex-1 px-5 py-4 rounded-xl border-2 bg-white border-purple-300 text-gray-900 focus:border-purple-500 focus:outline-none transition-all text-lg';
                prioritySelect.className = 'px-4 py-4 rounded-xl border-2 bg-white border-purple-300 text-gray-900 focus:border-purple-500 focus:outline-none transition-all flex-1';
                daySelect.className = 'px-4 py-4 rounded-xl border-2 bg-white border-purple-300 text-gray-900 focus:border-purple-500 focus:outline-none transition-all flex-1';
                const labels = progressContainer.querySelectorAll('span');
                if (labels[0]) labels[0].className = 'text-gray-900 font-semibold';
                if (labels[1]) labels[1].className = 'text-gray-600 font-bold';

                // Notes page light mode
                if (notesPage) {
                    const notesContainer = notesPage.querySelector('.bg-gray-800\\/90');
                    if (notesContainer) notesContainer.className = 'bg-white/90 backdrop-blur-lg rounded-2xl p-6 shadow-xl border border-purple-200';
                    // Notebook entry
                    if (notebookEntry) {
                        notebookEntry.className = 'bg-white/90 backdrop-blur-lg rounded-2xl p-6 md:p-8 mb-6 shadow-xl border border-purple-200';
                        const nbEntryLabels = notebookEntry.querySelectorAll('h2, h3, label, p');
                        nbEntryLabels.forEach(el => {
                            el.className = el.className.replace('text-gray-200', 'text-gray-800').replace('text-gray-300', 'text-gray-700').replace('text-gray-400', 'text-gray-600');
                        });
                    }
                    const noteSelectors = notesPage.querySelectorAll('select, input[type="text"], input[type="password"], textarea');
                    noteSelectors.forEach(el => {
                        if (el.id !== 'penColor' && el.id !== 'textColor' && el.id !== 'stickyColor') {
                            let className = el.className;
                            className = className.replace(/bg-gray-700/g, 'bg-white');
                            className = className.replace(/text-white/g, 'text-gray-900');
                            className = className.replace(/border-purple-500/g, 'border-purple-300');
                            el.className = className;
                        }
                    });
                    const noteLabels = notesPage.querySelectorAll('label, h2, h3');
                    noteLabels.forEach(el => {
                        el.className = el.className.replace('text-gray-200', 'text-gray-800').replace('text-gray-300', 'text-gray-700');
                    });
                    const noteSections = notesPage.querySelectorAll('.bg-gray-700\\/50');
                    noteSections.forEach(el => el.className = 'bg-gray-50 rounded-xl p-4 border-2 border-purple-200');
                    const stickyTextareas = notesPage.querySelectorAll('.sticky-note textarea');
                    stickyTextareas.forEach(el => el.className = el.className.replace(' text-white', ''));
                    const passwordModalContent = passwordModal.querySelector('.bg-gray-800');
                    if (passwordModalContent) passwordModalContent.className = 'bg-white rounded-2xl p-6 shadow-2xl max-w-md w-full mx-4';
                    const passwordModalInputs = passwordModal.querySelectorAll('input, button');
                    passwordModalInputs.forEach(el => {
                        if (el.type === 'password' || el.tagName === 'INPUT') {
                            el.className = el.className.replace('bg-gray-700', 'bg-white').replace('text-white', 'text-gray-900').replace('border-purple-500', 'border-purple-300');
                        }
                    });
                }
            }
            renderTodayTasks();
            renderCalendarTasks();
            renderHistory();
            if (currentPage === 'notes') {
                loadCurrentNote();
            }
        }

        function toggleDarkMode() {
            darkMode = !darkMode;
            saveTasks();
            applyDarkMode();
        }

        function playMeow() {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.setValueAtTime(800, ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(400, ctx.currentTime + 0.1);
                osc.type = 'sine';
                gain.gain.setValueAtTime(0.3, ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + 0.3);
                osc.start(ctx.currentTime);
                osc.stop(ctx.currentTime + 0.3);
            } catch (e) { }
        }

        function showConfetti() {
            const container = document.getElementById('confettiContainer');
            container.innerHTML = '';
            for (let i = 0; i < 50; i++) {
                const c = document.createElement('div');
                c.style.cssText = `position:fixed;left:${Math.random() * 100}%;top:-20px;width:12px;height:12px;border-radius:50%;background:hsl(${Math.random() * 360},70%,60%);animation:fall ${2 + Math.random() * 2}s ease-in ${Math.random() * 2}s forwards;z-index:9999`;
                container.appendChild(c);
            }
            setTimeout(() => container.innerHTML = '', 5000);
        }

        function updateProgress() {
            const today = new Date().toISOString().split('T')[0];
            const todayTasks = tasks.filter(t => !t.completed && (t.date === today || t.day === 'today'));
            const completed = tasks.filter(t => t.completed && t.completedDate && t.completedDate.startsWith(today)).length;
            const total = todayTasks.length + completed;
            const percent = total > 0 ? (completed / total) * 100 : 0;
            progressBar.style.width = percent + '%';
            progressText.textContent = `${completed} / ${total}`;
            if (total > 0 && completed === total && todayTasks.length === 0) {
                rewardMessage.style.display = 'block';
                showConfetti();
                setTimeout(() => rewardMessage.style.display = 'none', 5000);
            }
        }

        function getPriorityColor(p) {
            if (p === 'high') return 'from-pink-400 to-pink-600';
            if (p === 'medium') return 'from-purple-400 to-purple-600';
            return 'from-blue-400 to-blue-600';
        }

        function getPriorityText(p) {
            if (p === 'high') return 'Ø¹Ø§Ù„ÙŠ';
            if (p === 'medium') return 'Ù…ØªÙˆØ³Ø·';
            return 'Ù…Ù†Ø®ÙØ¶';
        }

        function getDayName(d) {
            const days = { 'today': 'Ø§Ù„ÙŠÙˆÙ…', 'tomorrow': 'ØºØ¯Ø§Ù‹', 'day3': 'Ø¨Ø¹Ø¯ ØºØ¯', 'day4': 'Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø±Ø§Ø¨Ø¹', 'day5': 'Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø®Ø§Ù…Ø³' };
            return days[d] || d;
        }

        function renderTodayTasks() {
            const today = new Date().toISOString().split('T')[0];
            const todayTasks = tasks.filter(t => !t.completed && (t.date === today || t.day === 'today'));
            const bg = darkMode ? 'bg-gray-800/90' : 'bg-white/90';
            const txt = darkMode ? 'text-gray-200' : 'text-gray-900';
            const bord = darkMode ? 'border-purple-700' : 'border-purple-200';
            const empty = darkMode ? 'text-gray-400' : 'text-gray-600';

            if (todayTasks.length === 0) {
                tasksList.innerHTML = `<div class="${bg} backdrop-blur-lg rounded-2xl p-12 text-center shadow-xl border ${bord}"><div style="font-size:4rem;margin-bottom:1rem;">â­</div><p class="${empty} text-xl">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ø§Ù„ÙŠÙˆÙ…. Ø§Ø¨Ø¯Ø£ Ø¨Ø¥Ø¶Ø§ÙØ© Ù…Ù‡Ù…Ø© Ø¬Ø¯ÙŠØ¯Ø©!</p></div>`;
                updateProgress();
                return;
            }

            tasksList.innerHTML = todayTasks.map(task => {
                const timer = activeTimers[task.id] || { running: false, elapsed: task.timeSpent || 0 };
                const display = formatTime(timer.elapsed);
                const btn = timer.running ?
                    `<button onclick="stopTimer(${task.id})" class="px-3 py-1 rounded-lg bg-gradient-to-r from-red-500 to-pink-500 text-white text-sm hover:opacity-80">â¸ Ø¥ÙŠÙ‚Ø§Ù</button>` :
                    `<button onclick="startTimer(${task.id})" class="px-3 py-1 rounded-lg bg-gradient-to-r from-green-500 to-emerald-500 text-white text-sm hover:opacity-80">â–¶ Ø¨Ø¯Ø¡</button>`;
                return `<div class="${bg} backdrop-blur-lg rounded-2xl p-5 shadow-lg border ${bord} hover:scale-[1.02] transition-all duration-200 task-item" data-id="${task.id}" draggable="true"><div class="flex flex-col gap-3"><div class="flex items-center gap-4"><button onclick="toggleTask(${task.id})" class="flex-shrink-0 w-7 h-7 rounded-lg border-2 flex items-center justify-center transition-all border-gray-300 hover:border-purple-500"></button><div class="flex-shrink-0 w-2 h-2 rounded-full bg-gradient-to-r ${getPriorityColor(task.priority)}"></div><span class="flex-1 text-lg ${txt}">${task.text}</span><button onclick="deleteTask(${task.id})" class="flex-shrink-0 p-2 rounded-lg bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white transition-all hover:scale-110">ğŸ—‘ï¸</button></div><div class="flex items-center justify-between gap-3 pr-12"><div class="flex items-center gap-2"><span class="text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}">${getPriorityText(task.priority)}</span></div><div class="flex items-center gap-2"><span id="timer-${task.id}" class="text-lg font-mono ${darkMode ? 'text-purple-400' : 'text-purple-600'} font-bold">â± ${display}</span>${btn}</div></div></div></div>`;
            }).join('');
            updateProgress();
        }

        function renderCalendarTasks() {
            const bg = darkMode ? 'bg-gray-800/90' : 'bg-white/90';
            const txt = darkMode ? 'text-gray-200' : 'text-gray-900';
            const bord = darkMode ? 'border-purple-700' : 'border-purple-200';
            const dayCards = document.getElementById('dayCards');
            const calendarTasks = document.getElementById('calendarTasks');
            const days = ['today', 'tomorrow', 'day3', 'day4', 'day5'];
            const colors = ['from-pink-500 to-purple-500', 'from-purple-500 to-blue-500', 'from-blue-500 to-green-500', 'from-green-500 to-yellow-500', 'from-yellow-500 to-pink-500'];

            dayCards.innerHTML = days.map((day, i) => {
                const dayTasks = tasks.filter(t => t.day === day);
                const completed = dayTasks.filter(t => t.completed).length;
                const total = dayTasks.length;
                return `<div class="${bg} backdrop-blur-lg rounded-2xl p-4 shadow-lg border ${bord}"><div class="text-center mb-3"><div class="text-xl font-bold ${txt}">${getDayName(day)}</div><div class="text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}">${getDateForDay(i)}</div></div><div class="mb-3"><div class="flex justify-between text-sm mb-1"><span class="${txt}">Ø§Ù„ØªÙ‚Ø¯Ù…</span><span class="${darkMode ? 'text-gray-400' : 'text-gray-600'}">${completed}/${total}</span></div><div class="w-full h-2 bg-gray-300 rounded-full overflow-hidden"><div class="h-full bg-gradient-to-r ${colors[i]}" style="width:${total > 0 ? (completed / total) * 100 : 0}%"></div></div></div><div class="text-center"><span class="text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}">${total} Ù…Ù‡Ø§Ù…</span></div></div>`;
            }).join('');

            calendarTasks.innerHTML = '';
            days.forEach((day, i) => {
                const dayTasks = tasks.filter(t => t.day === day);
                if (dayTasks.length === 0) return;
                const sec = document.createElement('div');
                sec.className = `${bg} backdrop-blur-lg rounded-2xl p-6 shadow-xl border ${bord}`;
                sec.innerHTML = `<h3 class="text-xl font-bold mb-4 flex items-center gap-2 ${txt}"><span>${getDayName(day)}</span><span class="text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}">(${getDateForDay(i)})</span></h3>`;
                const list = document.createElement('div');
                list.className = 'space-y-3';
                dayTasks.forEach(task => {
                    const el = document.createElement('div');
                    el.className = `p-4 rounded-xl border ${bord} ${task.completed ? 'opacity-70' : ''} task-item`;
                    el.setAttribute('data-id', task.id);
                    el.setAttribute('draggable', 'true');
                    el.setAttribute('data-day', day);
                    el.innerHTML = `<div class="flex items-center gap-3"><button onclick="toggleTask(${task.id})" class="flex-shrink-0 w-6 h-6 rounded-lg border-2 flex items-center justify-center transition-all ${task.completed ? 'bg-gradient-to-r from-green-500 to-emerald-500 border-green-500' : 'border-gray-300 hover:border-purple-500'}">${task.completed ? '<span style="color:white;font-size:1rem;">âœ“</span>' : ''}</button><div class="flex-shrink-0 w-2 h-2 rounded-full bg-gradient-to-r ${getPriorityColor(task.priority)}"></div><span class="flex-1 ${task.completed ? 'line-through' : ''} ${txt}">${task.text}</span><div class="flex items-center gap-2"><span class="text-xs px-2 py-1 rounded-full ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'}">${getPriorityText(task.priority)}</span><button onclick="moveTaskToToday(${task.id})" class="text-sm px-3 py-1 rounded-lg ${darkMode ? 'bg-purple-700 text-white' : 'bg-purple-100 text-purple-700'} hover:opacity-80 transition-all">â¡ï¸ Ø§Ù„ÙŠÙˆÙ…</button><button onclick="deleteTask(${task.id})" class="p-2 rounded-lg bg-gradient-to-r from-red-500 to-pink-500 hover:from-red-600 hover:to-pink-600 text-white transition-all hover:scale-110">ğŸ—‘ï¸</button></div></div>`;
                    list.appendChild(el);
                });
                sec.appendChild(list);
                calendarTasks.appendChild(sec);
            });
            setupDragAndDrop();
        }

        function renderHistory(filter = 'all') {
            const bg = darkMode ? 'bg-gray-800/90' : 'bg-white/90';
            const txt = darkMode ? 'text-gray-200' : 'text-gray-900';
            const bord = darkMode ? 'border-purple-700' : 'border-purple-200';
            const historyStats = document.getElementById('historyStats');
            const historyList = document.getElementById('historyList');
            const completed = tasks.filter(t => t.completed);
            let filtered = completed;
            const now = new Date();

            if (filter === 'week') {
                const weekAgo = new Date(now);
                weekAgo.setDate(weekAgo.getDate() - 7);
                filtered = completed.filter(t => (t.completedDate ? new Date(t.completedDate) : new Date()) >= weekAgo);
            } else if (filter === 'month') {
                const monthAgo = new Date(now);
                monthAgo.setMonth(monthAgo.getMonth() - 1);
                filtered = completed.filter(t => (t.completedDate ? new Date(t.completedDate) : new Date()) >= monthAgo);
            }

            filtered.sort((a, b) => {
                const dA = a.completedDate ? new Date(a.completedDate) : new Date(0);
                const dB = b.completedDate ? new Date(b.completedDate) : new Date(0);
                return dB - dA;
            });

            const totalTime = completed.reduce((s, t) => s + (t.timeSpent || 0), 0);
            const weekAgo = new Date(now);
            weekAgo.setDate(weekAgo.getDate() - 7);
            const weekCompleted = completed.filter(t => (t.completedDate ? new Date(t.completedDate) : new Date()) >= weekAgo);
            const weekTime = weekCompleted.reduce((s, t) => s + (t.timeSpent || 0), 0);
            const monthAgo = new Date(now);
            monthAgo.setMonth(monthAgo.getMonth() - 1);
            const monthCompleted = completed.filter(t => (t.completedDate ? new Date(t.completedDate) : new Date()) >= monthAgo);
            const monthTime = monthCompleted.reduce((s, t) => s + (t.timeSpent || 0), 0);

            historyStats.innerHTML = `<div class="${bg} backdrop-blur-lg rounded-2xl p-4 shadow-lg border ${bord} text-center"><div class="text-3xl font-bold ${txt}">${completed.length}</div><div class="${darkMode ? 'text-gray-400' : 'text-gray-600'}">Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ù…Ù‡Ø§Ù…</div><div class="text-lg font-bold text-purple-500 mt-1">â± ${formatTime(totalTime)}</div></div><div class="${bg} backdrop-blur-lg rounded-2xl p-4 shadow-lg border ${bord} text-center"><div class="text-3xl font-bold ${txt}">${weekCompleted.length}</div><div class="${darkMode ? 'text-gray-400' : 'text-gray-600'}">Ø¢Ø®Ø± Ø£Ø³Ø¨ÙˆØ¹</div><div class="text-lg font-bold text-blue-500 mt-1">â± ${formatTime(weekTime)}</div></div><div class="${bg} backdrop-blur-lg rounded-2xl p-4 shadow-lg border ${bord} text-center"><div class="text-3xl font-bold ${txt}">${monthCompleted.length}</div><div class="${darkMode ? 'text-gray-400' : 'text-gray-600'}">Ø¢Ø®Ø± Ø´Ù‡Ø±</div><div class="text-lg font-bold text-green-500 mt-1">â± ${formatTime(monthTime)}</div></div>`;

            if (filtered.length === 0) {
                historyList.innerHTML = `<div class="${bg} backdrop-blur-lg rounded-2xl p-12 text-center shadow-xl border ${bord}"><div style="font-size:4rem;margin-bottom:1rem;">ğŸ“Š</div><p class="${darkMode ? 'text-gray-400' : 'text-gray-600'} text-xl">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù‡Ø§Ù… Ù…ÙƒØªÙ…Ù„Ø© Ø¨Ø¹Ø¯!</p><p class="${darkMode ? 'text-gray-500' : 'text-gray-500'} mt-2">Ø§ÙƒÙ…Ù„ Ø¨Ø¹Ø¶ Ø§Ù„Ù…Ù‡Ø§Ù… Ù„ØªØ±Ø§Ù‡Ø§ Ù‡Ù†Ø§</p></div>`;
                return;
            }

            const grouped = { 'Ø§Ù„ÙŠÙˆÙ…': [], 'Ø£Ù…Ø³': [], 'Ø¢Ø®Ø± Ø£Ø³Ø¨ÙˆØ¹': [], 'Ø³Ø§Ø¨Ù‚Ø§Ù‹': [] };
            filtered.forEach(task => grouped[getRelativeDate(task.completedDate)].push(task));

            let html = '';
            for (const [group, groupTasks] of Object.entries(grouped)) {
                if (groupTasks.length === 0) continue;
                const groupTime = groupTasks.reduce((s, t) => s + (t.timeSpent || 0), 0);
                html += `<div class="mb-6"><div class="flex items-center justify-between mb-3"><h3 class="text-xl font-bold ${txt}">${group}</h3><div class="flex items-center gap-3"><span class="${darkMode ? 'text-gray-400' : 'text-gray-600'}">${groupTasks.length} Ù…Ù‡Ø§Ù…</span><span class="text-purple-500 font-bold">â± ${formatTime(groupTime)}</span></div></div><div class="space-y-3">`;
                groupTasks.forEach(task => {
                    const dateStr = formatDate(task.completedDate ? new Date(task.completedDate) : new Date());
                    const timeStr = task.timeSpent ? formatTime(task.timeSpent) : '0Ø«';
                    html += `<div class="${bg} backdrop-blur-lg rounded-2xl p-5 shadow-lg border ${bord}"><div class="flex items-start gap-4"><div class="flex-shrink-0 w-10 h-10 rounded-full bg-gradient-to-r from-green-400 to-emerald-600 flex items-center justify-center text-white text-xl">âœ“</div><div class="flex-1"><div class="flex justify-between items-start mb-2"><span class="text-lg ${txt}">${task.text}</span><span class="text-sm ${darkMode ? 'text-gray-400' : 'text-gray-600'}">${dateStr}</span></div><div class="flex flex-wrap gap-2"><span class="text-xs px-2 py-1 rounded-full ${darkMode ? 'bg-gray-700 text-gray-300' : 'bg-gray-100 text-gray-700'}">${getPriorityText(task.priority)}</span><span class="text-xs px-2 py-1 rounded-full ${darkMode ? 'bg-purple-700 text-purple-300' : 'bg-purple-100 text-purple-700'}">${getDayName(task.originalDay || task.day)}</span><span class="text-xs px-2 py-1 rounded-full ${darkMode ? 'bg-blue-700 text-blue-300' : 'bg-blue-100 text-blue-700'} font-bold">â± ${timeStr}</span></div></div></div></div>`;
                });
                html += `</div></div>`;
            }
            historyList.innerHTML = html;
        }

        function addTask() {
            const text = taskInput.value.trim();
            if (!text) return;
            const day = daySelect.value;
            const today = new Date().toISOString().split('T')[0];
            const date = day === 'today' ? today : getDateForFutureDay(day);
            tasks.push({
                id: Date.now(),
                text: text,
                completed: false,
                priority: prioritySelect.value,
                day: day,
                date: date,
                createdAt: new Date().toISOString(),
                timeSpent: 0
            });
            taskInput.value = '';
            prioritySelect.value = 'medium';
            daySelect.value = 'today';
            saveTasks();
            renderTodayTasks();
            renderCalendarTasks();
            if (currentPage === 'notes') {
                updateNoteTaskSelector();
            }
        }

        function getDateForFutureDay(day) {
            const date = new Date();
            const offsets = { 'today': 0, 'tomorrow': 1, 'day3': 2, 'day4': 3, 'day5': 4 };
            date.setDate(date.getDate() + (offsets[day] || 0));
            return date.toISOString().split('T')[0];
        }

        function toggleTask(id) {
            const task = tasks.find(t => t.id === id);
            if (!task) return;
            if (activeTimers[id]?.running) stopTimer(id);
            if (!task.completed) {
                task.completed = true;
                task.completedDate = new Date().toISOString();
                task.originalDay = task.day;
                playMeow();
                const el = document.querySelector(`[data-id="${id}"]`);
                if (el) {
                    el.style.transform = 'scale(0.8)';
                    el.style.opacity = '0';
                    setTimeout(() => {
                        saveTasks();
                        renderTodayTasks();
                        renderCalendarTasks();
                        showConfetti();
                    }, 300);
                }
            } else {
                task.completed = false;
                task.completedDate = null;
                saveTasks();
                renderTodayTasks();
                renderCalendarTasks();
            }
            if (currentPage === 'history') renderHistory('all');
        }

        function startTimer(id) {
            const task = tasks.find(t => t.id === id);
            if (!task) return;
            Object.keys(activeTimers).forEach(timerId => {
                if (activeTimers[timerId].running && timerId != id) stopTimer(parseInt(timerId));
            });
            if (!activeTimers[id]) {
                activeTimers[id] = { running: true, elapsed: task.timeSpent || 0, startTime: Date.now(), interval: null };
            } else {
                activeTimers[id].running = true;
                activeTimers[id].startTime = Date.now();
            }
            activeTimers[id].interval = setInterval(() => {
                const elapsed = activeTimers[id].elapsed + Math.floor((Date.now() - activeTimers[id].startTime) / 1000);
                const el = document.getElementById(`timer-${id}`);
                if (el) el.textContent = `â± ${formatTime(elapsed)}`;
            }, 1000);
            renderTodayTasks();
        }

        function stopTimer(id) {
            if (!activeTimers[id] || !activeTimers[id].running) return;
            const additionalTime = Math.floor((Date.now() - activeTimers[id].startTime) / 1000);
            activeTimers[id].elapsed += additionalTime;
            activeTimers[id].running = false;
            clearInterval(activeTimers[id].interval);
            const task = tasks.find(t => t.id === id);
            if (task) {
                task.timeSpent = activeTimers[id].elapsed;
                saveTasks();
            }
            renderTodayTasks();
        }

        function deleteTask(id) {
            if (activeTimers[id]?.running) stopTimer(id);
            tasks = tasks.filter(t => t.id !== id);
            saveTasks();
            if (currentPage === 'today') renderTodayTasks();
            else if (currentPage === 'calendar') renderCalendarTasks();
            else if (currentPage === 'history') renderHistory('all');
            else if (currentPage === 'notes') updateNoteTaskSelector();
        }

        function moveTaskToToday(id) {
            const task = tasks.find(t => t.id === id);
            if (task) {
                task.day = 'today';
                task.date = new Date().toISOString().split('T')[0];
                saveTasks();
                renderCalendarTasks();
                renderTodayTasks();
            }
        }

        function setupDragAndDrop() {
            document.querySelectorAll('.task-item').forEach(item => {
                item.addEventListener('dragstart', e => e.dataTransfer.setData('text/plain', e.target.dataset.id));
            });
            document.querySelectorAll('#calendarPage > div > div').forEach(section => {
                section.addEventListener('dragover', e => {
                    e.preventDefault();
                    section.style.opacity = '0.8';
                });
                section.addEventListener('dragleave', () => section.style.opacity = '1');
                section.addEventListener('drop', e => {
                    e.preventDefault();
                    section.style.opacity = '1';
                    const taskId = e.dataTransfer.getData('text/plain');
                    const dayHeader = section.querySelector('h3');
                    if (dayHeader) {
                        const dayText = dayHeader.textContent;
                        const dayMap = { 'Ø§Ù„ÙŠÙˆÙ…': 'today', 'ØºØ¯Ø§Ù‹': 'tomorrow', 'Ø¨Ø¹Ø¯ ØºØ¯': 'day3', 'Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø±Ø§Ø¨Ø¹': 'day4', 'Ø§Ù„ÙŠÙˆÙ… Ø§Ù„Ø®Ø§Ù…Ø³': 'day5' };
                        let targetDay = 'today';
                        for (const [key, value] of Object.entries(dayMap)) {
                            if (dayText.includes(key)) {
                                targetDay = value;
                                break;
                            }
                        }
                        const task = tasks.find(t => t.id == taskId);
                        if (task) {
                            task.day = targetDay;
                            task.date = getDateForFutureDay(targetDay);
                            saveTasks();
                            renderCalendarTasks();
                            renderTodayTasks();
                        }
                    }
                });
            });
        }

        function switchPage(page) {
            currentPage = page;
            todayPage.classList.remove('active');
            calendarPage.classList.remove('active');
            historyPage.classList.remove('active');
            notesPage.classList.remove('active');
            todayTab.classList.remove('active');
            calendarTab.classList.remove('active');
            historyTab.classList.remove('active');
            notesTab.classList.remove('active');
            if (page === 'today') {
                todayPage.classList.add('active');
                todayTab.classList.add('active');
            } else if (page === 'calendar') {
                calendarPage.classList.add('active');
                calendarTab.classList.add('active');
                renderCalendarTasks();
            } else if (page === 'history') {
                historyPage.classList.add('active');
                historyTab.classList.add('active');
                renderHistory('all');
            } else if (page === 'notes') {
                notesPage.classList.add('active');
                notesTab.classList.add('active');
                updateNoteTaskSelector();
                loadCurrentNote();
            }
        }

        // ========== NOTEBOOK SYSTEM (Notability-like) ==========
        // ARCHITECTURE:
        // - Full-screen notebook with infinite vertical scroll
        // - Pages: Each page is a canvas layer on top of optional content (blank/image/PDF)
        // - Strokes: Vector-based, smoothed with quadratic curves, stored per page
        // - Layers: Base (content) -> Annotation (strokes) - move together on scroll
        // - Persistence: All data in LocalStorage including scroll position

        // Notebook State
        let notebookOpen = false;
        let nbPages = [];
        let nbCurrentPageIndex = 0;
        let nbTool = 'pen';
        let nbIsDrawing = false;
        let nbCurrentStroke = null;
        let nbStrokesHistory = [];
        let nbRedoStack = [];
        let nbScrollPosition = 0;

        // Initialize PDF.js worker
        if (typeof pdfjsLib !== 'undefined') {
            pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
        }

        // Notebook DOM Elements
        const notebookFullscreen = document.getElementById('notebookFullscreen');
        const notebookCanvasArea = document.getElementById('notebookCanvasArea');
        const notebookPaper = document.getElementById('notebookPaper');
        const notebookSidebar = document.getElementById('notebookSidebar');
        const sidebarPagesList = document.getElementById('sidebarPagesList');
        const sidebarAttachments = document.getElementById('sidebarAttachments');
        const openNotebookBtn = document.getElementById('openNotebookBtn');
        const closeNotebookBtn = document.getElementById('closeNotebookBtn');
        const nbPenColor = document.getElementById('nbPenColor');
        const nbPenThickness = document.getElementById('nbPenThickness');
        const nbThicknessValue = document.getElementById('nbThicknessValue');
        const nbPenBtn = document.getElementById('nbPenBtn');
        const nbHighlighterBtn = document.getElementById('nbHighlighterBtn');
        const nbEraserBtn = document.getElementById('nbEraserBtn');
        const nbUndoBtn = document.getElementById('nbUndoBtn');
        const nbRedoBtn = document.getElementById('nbRedoBtn');
        const nbAddFileBtn = document.getElementById('nbAddFileBtn');
        const nbFileInput = document.getElementById('nbFileInput');
        const nbAddPageBtn = document.getElementById('nbAddPageBtn');
        const nbAddPageSidebar = document.getElementById('nbAddPageSidebar');
        const nbExportBtn = document.getElementById('nbExportBtn');
        const nbToggleSidebar = document.getElementById('nbToggleSidebar');
        const notebookEntry = document.getElementById('notebookEntry');

        // Enhanced stroke smoothing with variable thickness simulation
        function smoothStrokePoints(points) {
            if (points.length < 3) return points;
            const smoothed = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                const prev = points[i - 1];
                const curr = points[i];
                const next = points[i + 1];
                // Catmull-Rom inspired smoothing
                smoothed.push({
                    x: curr.x * 0.5 + (prev.x + next.x) * 0.25,
                    y: curr.y * 0.5 + (prev.y + next.y) * 0.25,
                    pressure: curr.pressure || 1
                });
            }
            smoothed.push(points[points.length - 1]);
            return smoothed;
        }

        // Draw stroke with natural feel
        function drawNaturalStroke(ctx, stroke, scale = 1) {
            const pts = stroke.points || [];
            if (pts.length < 2) return;

            const smoothed = smoothStrokePoints(pts);
            const baseWidth = (stroke.width || 3) * scale;

            ctx.save();
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            if (stroke.isEraser) {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = 'rgba(0,0,0,1)';
                ctx.lineWidth = baseWidth * 2;
            } else if (stroke.isHighlighter) {
                ctx.globalCompositeOperation = 'multiply';
                ctx.globalAlpha = 0.3;
                ctx.strokeStyle = stroke.color || '#ffff00';
                ctx.lineWidth = baseWidth * 4;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.strokeStyle = stroke.color || '#000000';
                ctx.lineWidth = baseWidth;
            }

            ctx.beginPath();
            ctx.moveTo(smoothed[0].x * scale, smoothed[0].y * scale);

            for (let i = 1; i < smoothed.length - 1; i++) {
                const xc = (smoothed[i].x + smoothed[i + 1].x) / 2 * scale;
                const yc = (smoothed[i].y + smoothed[i + 1].y) / 2 * scale;
                ctx.quadraticCurveTo(smoothed[i].x * scale, smoothed[i].y * scale, xc, yc);
            }

            const last = smoothed[smoothed.length - 1];
            ctx.lineTo(last.x * scale, last.y * scale);
            ctx.stroke();
            ctx.restore();
        }

        // Get current notebook data
        function getNotebookData() {
            const note = getCurrentNote();
            if (!note.notebook) {
                note.notebook = {
                    pages: [{
                        id: Date.now(),
                        type: 'blank',
                        height: 1200,
                        strokes: [],
                        content: null
                    }],
                    toolState: {
                        color: '#000000',
                        thickness: 3,
                        tool: 'pen'
                    },
                    scrollPosition: 0,
                    lastModified: new Date().toISOString()
                };
            }
            return note.notebook;
        }

        // Save notebook state
        function saveNotebook() {
            const note = getCurrentNote();
            const nb = getNotebookData();
            nb.scrollPosition = notebookCanvasArea ? notebookCanvasArea.scrollTop : 0;
            nb.toolState = {
                color: nbPenColor.value,
                thickness: parseInt(nbPenThickness.value),
                tool: nbTool
            };
            nb.lastModified = new Date().toISOString();
            note.notebook = nb;
            saveNotes();

            // Update history view if sidebar is open
            if (notebookSidebar && notebookSidebar.style.transform === 'translateX(0px)') {
                renderNotesHistory();
            }
        }

        // Open notebook fullscreen
        function openNotebook() {
            notebookOpen = true;
            notebookFullscreen.classList.remove('hidden');
            document.body.style.overflow = 'hidden';

            const nb = getNotebookData();
            nbPenColor.value = nb.toolState?.color || '#000000';
            nbPenThickness.value = nb.toolState?.thickness || 3;
            nbThicknessValue.textContent = (nb.toolState?.thickness || 3) + 'px';
            nbTool = nb.toolState?.tool || 'pen';
            updateNbToolButtons();

            renderNotebookPages();
            renderSidebarPages();
            renderSidebarAttachments();
            renderNotesHistory();

            // Render sticky notes
            if (typeof renderNotebookStickies === 'function') {
                renderNotebookStickies();
            }

            setTimeout(() => {
                notebookCanvasArea.scrollTop = nb.scrollPosition || 0;
            }, 100);
        }

        // Close notebook
        function closeNotebook() {
            saveNotebook();
            notebookOpen = false;
            notebookFullscreen.classList.add('hidden');
            document.body.style.overflow = '';
        }

        // Update tool button states
        function updateNbToolButtons() {
            nbPenBtn.classList.toggle('active', nbTool === 'pen');
            nbHighlighterBtn.classList.toggle('active', nbTool === 'highlighter');
            nbEraserBtn.classList.toggle('active', nbTool === 'eraser');
        }

        // Render all notebook pages - CLEARS ALL and re-renders
        function renderNotebookPages() {
            const nb = getNotebookData();

            // CRITICAL: Clear EVERYTHING first to prevent duplicates
            notebookPaper.innerHTML = '';

            // Create stickies layer fresh
            const stickiesLayer = document.createElement('div');
            stickiesLayer.id = 'nbStickiesLayer';
            stickiesLayer.className = 'nb-stickies-layer';
            notebookPaper.appendChild(stickiesLayer);

            let totalHeight = 0;
            nb.pages.forEach((page, index) => {
                const pageEl = createPageElement(page, index, totalHeight);
                notebookPaper.appendChild(pageEl);
                totalHeight += page.height;
            });

            // Set paper height for infinite scroll
            notebookPaper.style.minHeight = Math.max(totalHeight, 2400) + 'px';

            // Update stickies layer height to match paper
            stickiesLayer.style.height = Math.max(totalHeight, 2400) + 'px';
        }

        // Add new page to notebook
        function addNotebookPage(type = 'blank', content = null, silent = false) {
            const nb = getNotebookData();

            // Prevent duplicate silent adds
            if (silent && window.nbAddingPage) return;
            if (silent) window.nbAddingPage = true;

            const newPage = {
                id: Date.now(),
                type: type,
                height: type === 'blank' ? 1200 : 1000,
                strokes: [],
                content: content
            };
            nb.pages.push(newPage);
            saveNotebook();

            if (!silent) {
                renderNotebookPages();
                renderSidebarPages();

                // Scroll to new page
                setTimeout(() => {
                    const pageEls = notebookPaper.querySelectorAll('.notebook-page');
                    if (pageEls.length > 0) {
                        const lastPage = pageEls[pageEls.length - 1];
                        lastPage.scrollIntoView({ behavior: 'smooth' });
                    }
                }, 100);
            } else {
                // Just append the new page
                const pageEl = createPageElement(newPage, nb.pages.length - 1, 0);
                notebookPaper.appendChild(pageEl);

                // Update paper height
                let totalHeight = 0;
                nb.pages.forEach(p => totalHeight += p.height);
                notebookPaper.style.minHeight = Math.max(totalHeight, 2400) + 'px';
            }

            if (silent) {
                setTimeout(() => { window.nbAddingPage = false; }, 500);
            }
        }

        // Create page element with canvas
        function createPageElement(page, index, offsetY) {
            const pageEl = document.createElement('div');
            pageEl.className = 'notebook-page notebook-page-enter';
            pageEl.dataset.pageIndex = index;
            pageEl.style.height = page.height + 'px';

            // Content layer (for images/PDFs)
            const contentEl = document.createElement('div');
            contentEl.className = 'notebook-page-content';

            // Delete button for file pages (PDF/image)
            if (page.type === 'image' || page.type === 'pdf') {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'notebook-page-delete';
                deleteBtn.innerHTML = 'ğŸ—‘ï¸';
                deleteBtn.title = 'Ø­Ø°Ù Ø§Ù„ØµÙØ­Ø©';
                deleteBtn.style.pointerEvents = 'auto';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø© ÙˆØ§Ù„ØªØ¹Ù„ÙŠÙ‚Ø§Øª Ø¹Ù„ÙŠÙ‡Ø§ØŸ')) {
                        deleteNotebookPage(index);
                    }
                };
                pageEl.appendChild(deleteBtn);
            }

            if (page.type === 'image' && page.content) {
                const imageContainer = document.createElement('div');
                imageContainer.className = 'notebook-inline-file';

                const img = document.createElement('img');
                img.src = page.content;
                img.style.width = '100%';
                img.style.display = 'block';
                img.onload = () => {
                    // Create annotation overlay after image loads
                    const annotOverlay = document.createElement('canvas');
                    annotOverlay.className = 'notebook-annotation-overlay';
                    annotOverlay.width = img.naturalWidth || img.width;
                    annotOverlay.height = img.naturalHeight || img.height;
                    annotOverlay.dataset.pageIndex = index;
                    annotOverlay.dataset.type = 'image';
                    imageContainer.appendChild(annotOverlay);

                    // Draw existing strokes on image
                    const ctx = annotOverlay.getContext('2d');
                    (page.strokes || []).forEach(stroke => drawNaturalStroke(ctx, stroke));

                    // Setup drawing events for image annotation
                    setupFileAnnotationEvents(annotOverlay, index, 'image', 0);
                };
                imageContainer.appendChild(img);
                contentEl.appendChild(imageContainer);

            } else if (page.type === 'pdf' && page.pdfData) {
                // PDF - use embed for native browser rendering (clearer text)
                const pdfContainer = document.createElement('div');
                pdfContainer.className = 'notebook-inline-file pdf-page-container';
                pdfContainer.id = `pdf-container-${index}`;
                pdfContainer.dataset.pageIndex = index;
                pdfContainer.style.position = 'relative';
                pdfContainer.style.marginBottom = '20px';
                pdfContainer.style.width = '100%';
                pdfContainer.style.height = (page.height || 800) + 'px';

                // Convert base64 to blob URL
                const base64 = page.pdfData.replace(/^data:application\/pdf;base64,/, '');
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                const blob = new Blob([bytes], { type: 'application/pdf' });
                const blobUrl = URL.createObjectURL(blob);

                // Create embed element for native PDF rendering
                const pdfEmbed = document.createElement('embed');
                pdfEmbed.src = blobUrl;
                pdfEmbed.type = 'application/pdf';
                pdfEmbed.style.width = '100%';
                pdfEmbed.style.height = '100%';
                pdfEmbed.style.border = 'none';
                pdfEmbed.style.pointerEvents = 'auto';
                pdfContainer.appendChild(pdfEmbed);

                // Drawing canvas overlay (transparent, on top of embed)
                const drawCanvas = document.createElement('canvas');
                drawCanvas.id = `pdf-draw-${index}`;
                drawCanvas.className = 'notebook-annotation-overlay';
                drawCanvas.dataset.pageIndex = index;
                drawCanvas.width = 900;
                drawCanvas.height = page.height || 800;
                drawCanvas.style.position = 'absolute';
                drawCanvas.style.top = '0';
                drawCanvas.style.left = '0';
                drawCanvas.style.width = '100%';
                drawCanvas.style.height = '100%';
                drawCanvas.style.zIndex = '20';
                drawCanvas.style.pointerEvents = 'auto';
                drawCanvas.style.touchAction = 'none';
                drawCanvas.style.cursor = 'crosshair';
                drawCanvas.style.background = 'transparent';
                pdfContainer.appendChild(drawCanvas);

                // Draw existing strokes on canvas
                const ctx = drawCanvas.getContext('2d');
                (page.strokes || []).forEach(stroke => drawNaturalStroke(ctx, stroke));

                // Setup drawing events for this canvas
                setupPageDrawingEvents(drawCanvas, index);

                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'notebook-page-delete';
                deleteBtn.innerHTML = 'ğŸ—‘ï¸';
                deleteBtn.title = 'Ø­Ø°Ù Ù…Ù„Ù PDF';
                deleteBtn.style.zIndex = '30';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Ø­Ø°Ù Ù…Ù„Ù PDF ÙƒØ§Ù…Ù„ØŸ')) {
                        URL.revokeObjectURL(blobUrl); // Clean up
                        deleteNotebookPage(index);
                    }
                };
                pdfContainer.appendChild(deleteBtn);

                contentEl.appendChild(pdfContainer);
            }

            pageEl.appendChild(contentEl);

            // Main annotation canvas for blank pages only
            if (page.type === 'blank' || (!page.type)) {
                const canvas = document.createElement('canvas');
                canvas.className = 'notebook-page-canvas';
                canvas.dataset.pageIndex = index;
                canvas.width = 900;
                canvas.height = page.height;
                pageEl.appendChild(canvas);

                // Draw existing strokes
                const ctx = canvas.getContext('2d');
                (page.strokes || []).forEach(stroke => drawNaturalStroke(ctx, stroke));

                // Setup drawing events
                setupPageDrawingEvents(canvas, index);
            }

            // Page number
            const pageNum = document.createElement('div');
            pageNum.className = 'notebook-page-number';
            pageNum.textContent = `ØµÙØ­Ø© ${index + 1}`;
            pageEl.appendChild(pageNum);

            return pageEl;
        }

        // SIMPLEST PDF renderer - no transforms, no scaling tricks
        async function renderSinglePdfPage(pdfData, pageNum, pdfCanvas, annotCanvas, pageIndex, pdfIdx, annotations) {
            // Validate inputs
            if (!pdfData || !pdfCanvas || typeof pdfjsLib === 'undefined') {
                console.error('renderSinglePdfPage: Invalid inputs');
                return;
            }

            // Check if already rendered
            if (pdfCanvas.dataset.rendered === 'true') {
                return;
            }

            try {
                // Convert base64 to bytes
                const base64 = pdfData.replace(/^data:application\/pdf;base64,/, '');
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }

                // Load PDF
                const pdf = await pdfjsLib.getDocument({ data: bytes }).promise;
                const page = await pdf.getPage(pageNum);

                // Simple fixed scale - higher for better quality
                const scale = 2.0;
                const viewport = page.getViewport({ scale: scale });

                // Canvas size = viewport size (no tricks)
                pdfCanvas.width = viewport.width;
                pdfCanvas.height = viewport.height;

                // CSS size = canvas size (1:1, no scaling)
                pdfCanvas.style.width = viewport.width + 'px';
                pdfCanvas.style.height = viewport.height + 'px';

                // Container size
                const container = pdfCanvas.parentElement;
                if (container) {
                    container.style.width = viewport.width + 'px';
                    container.style.height = viewport.height + 'px';
                }

                // Annotation canvas
                if (annotCanvas) {
                    annotCanvas.width = viewport.width;
                    annotCanvas.height = viewport.height;
                    annotCanvas.style.position = 'absolute';
                    annotCanvas.style.top = '0';
                    annotCanvas.style.left = '0';
                    annotCanvas.style.width = viewport.width + 'px';
                    annotCanvas.style.height = viewport.height + 'px';
                }

                // Get context, clear, render
                const ctx = pdfCanvas.getContext('2d');
                ctx.clearRect(0, 0, viewport.width, viewport.height);

                await page.render({
                    canvasContext: ctx,
                    viewport: viewport
                }).promise;

                // Mark as rendered
                pdfCanvas.dataset.rendered = 'true';

                // Draw annotations
                if (annotCanvas && annotations && annotations.length > 0) {
                    const annotCtx = annotCanvas.getContext('2d');
                    annotCtx.clearRect(0, 0, annotCanvas.width, annotCanvas.height);
                    annotations.forEach(stroke => drawNaturalStroke(annotCtx, stroke, scale));
                }

                // Setup drawing events
                if (annotCanvas) {
                    setupFileAnnotationEvents(annotCanvas, pageIndex, 'pdf', pdfIdx);
                }

            } catch (error) {
                console.error('PDF render error:', error);
            }
        }

        // Setup drawing events for file annotation overlays (PDF/image)
        function setupFileAnnotationEvents(canvas, pageIndex, fileType, subIndex) {
            const getCoords = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            let isDrawing = false;
            let currentStroke = null;

            canvas.addEventListener('mousedown', (e) => {
                isDrawing = true;
                const coords = getCoords(e);
                currentStroke = {
                    points: [{ x: coords.x, y: coords.y, pressure: 1 }],
                    color: nbPenColor.value,
                    width: parseInt(nbPenThickness.value),
                    isEraser: nbTool === 'eraser',
                    isHighlighter: nbTool === 'highlighter',
                    fileType: fileType,
                    subIndex: subIndex
                };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentStroke) return;
                const coords = getCoords(e);
                currentStroke.points.push({ x: coords.x, y: coords.y, pressure: 1 });

                // Live preview
                const ctx = canvas.getContext('2d');
                drawNaturalStroke(ctx, currentStroke);
            });

            const endStroke = () => {
                if (isDrawing && currentStroke && currentStroke.points.length > 1) {
                    // Save annotation to notebook data
                    const nb = getNotebookData();
                    const page = nb.pages[pageIndex];

                    if (fileType === 'pdf') {
                        if (!page.pdfAnnotations) page.pdfAnnotations = {};
                        if (!page.pdfAnnotations[subIndex]) page.pdfAnnotations[subIndex] = [];
                        page.pdfAnnotations[subIndex].push(currentStroke);
                    } else {
                        // Image annotations go to page.strokes
                        if (!page.strokes) page.strokes = [];
                        page.strokes.push(currentStroke);
                    }

                    nbStrokesHistory.push({ pageIndex: pageIndex, stroke: currentStroke, fileType, subIndex });
                    nbRedoStack = [];
                    saveNotebook();
                }
                currentStroke = null;
                isDrawing = false;
            };

            canvas.addEventListener('mouseup', endStroke);
            canvas.addEventListener('mouseleave', endStroke);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                isDrawing = true;
                const coords = getCoords(e);
                currentStroke = {
                    points: [{ x: coords.x, y: coords.y, pressure: 1 }],
                    color: nbPenColor.value,
                    width: parseInt(nbPenThickness.value),
                    isEraser: nbTool === 'eraser',
                    isHighlighter: nbTool === 'highlighter',
                    fileType: fileType,
                    subIndex: subIndex
                };
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDrawing || !currentStroke) return;
                const coords = getCoords(e);
                currentStroke.points.push({ x: coords.x, y: coords.y, pressure: 1 });
                const ctx = canvas.getContext('2d');
                drawNaturalStroke(ctx, currentStroke);
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                endStroke();
            }, { passive: false });
        }

        // Delete a notebook page - completely removes from DOM and storage
        function deleteNotebookPage(pageIndex) {
            const nb = getNotebookData();
            if (pageIndex < 0 || pageIndex >= nb.pages.length) return;

            // Save current scroll position
            const currentScroll = notebookCanvasArea ? notebookCanvasArea.scrollTop : 0;

            // Remove the page from data
            nb.pages.splice(pageIndex, 1);

            // If no pages left, add a blank one
            if (nb.pages.length === 0) {
                nb.pages.push({
                    id: Date.now(),
                    type: 'blank',
                    height: 1200,
                    strokes: []
                });
            }

            // Update note object and save
            const note = getCurrentNote();
            note.notebook = nb;
            saveNotes();

            // Force complete DOM refresh
            // 1. Clear the entire paper container
            while (notebookPaper.firstChild) {
                notebookPaper.removeChild(notebookPaper.firstChild);
            }

            // 2. Also clear sidebar lists
            if (sidebarPagesList) sidebarPagesList.innerHTML = '';
            if (sidebarAttachments) sidebarAttachments.innerHTML = '';

            // 3. Re-render everything from scratch
            renderNotebookPages();
            renderSidebarPages();
            renderSidebarAttachments();

            // 4. Re-render stickies if exists
            if (typeof renderNotebookStickies === 'function') {
                renderNotebookStickies();
            }

            // 5. Restore scroll position
            setTimeout(() => {
                if (notebookCanvasArea && notebookPaper) {
                    const maxScroll = notebookPaper.scrollHeight - notebookCanvasArea.clientHeight;
                    notebookCanvasArea.scrollTop = Math.min(currentScroll, Math.max(0, maxScroll));
                }
            }, 150);
        }

        // Make delete function global
        window.deleteNotebookPage = deleteNotebookPage;

        // NOTE: renderPdfToCanvas removed - use renderPdfPageWithAnnotation instead

        // Setup drawing events for a page canvas
        function setupPageDrawingEvents(canvas, pageIndex) {
            const getCoords = (e) => {
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) * scaleX,
                    y: (clientY - rect.top) * scaleY
                };
            };

            canvas.addEventListener('mousedown', (e) => {
                nbIsDrawing = true;
                nbCurrentPageIndex = pageIndex;
                const coords = getCoords(e);
                nbCurrentStroke = {
                    points: [{ x: coords.x, y: coords.y, pressure: 1 }],
                    color: nbPenColor.value,
                    width: parseInt(nbPenThickness.value),
                    isEraser: nbTool === 'eraser',
                    isHighlighter: nbTool === 'highlighter',
                    pageIndex: pageIndex
                };
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!nbIsDrawing || !nbCurrentStroke) return;
                const coords = getCoords(e);
                nbCurrentStroke.points.push({ x: coords.x, y: coords.y, pressure: 1 });

                // Live preview
                const ctx = canvas.getContext('2d');
                drawNaturalStroke(ctx, nbCurrentStroke);
            });

            const endStroke = () => {
                if (nbIsDrawing && nbCurrentStroke && nbCurrentStroke.points.length > 1) {
                    const nb = getNotebookData();
                    const page = nb.pages[nbCurrentPageIndex];
                    if (!page.strokes) page.strokes = [];
                    page.strokes.push(nbCurrentStroke);
                    nbStrokesHistory.push({ pageIndex: nbCurrentPageIndex, stroke: nbCurrentStroke });
                    nbRedoStack = [];
                    saveNotebook();
                }
                nbCurrentStroke = null;
                nbIsDrawing = false;
            };

            canvas.addEventListener('mouseup', endStroke);
            canvas.addEventListener('mouseleave', endStroke);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                nbIsDrawing = true;
                nbCurrentPageIndex = pageIndex;
                const coords = getCoords(e);
                nbCurrentStroke = {
                    points: [{ x: coords.x, y: coords.y, pressure: 1 }],
                    color: nbPenColor.value,
                    width: parseInt(nbPenThickness.value),
                    isEraser: nbTool === 'eraser',
                    isHighlighter: nbTool === 'highlighter',
                    pageIndex: pageIndex
                };
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!nbIsDrawing || !nbCurrentStroke) return;
                const coords = getCoords(e);
                nbCurrentStroke.points.push({ x: coords.x, y: coords.y, pressure: 1 });
                const ctx = canvas.getContext('2d');
                drawNaturalStroke(ctx, nbCurrentStroke);
            }, { passive: false });

            canvas.addEventListener('touchend', (e) => {
                e.preventDefault();
                endStroke();
            }, { passive: false });
        }

        // Add new page
        function addNotebookPage(type = 'blank', content = null) {
            const nb = getNotebookData();
            const newPage = {
                id: Date.now(),
                type: type,
                height: type === 'blank' ? 1200 : 1000,
                strokes: [],
                content: content
            };
            nb.pages.push(newPage);
            saveNotebook();
            renderNotebookPages();
            renderSidebarPages();

            // Scroll to new page
            setTimeout(() => {
                const totalHeight = nb.pages.slice(0, -1).reduce((h, p) => h + p.height, 0);
                notebookCanvasArea.scrollTo({ top: totalHeight, behavior: 'smooth' });
            }, 100);
        }

        // Add image/PDF as inline page
        async function addFileToNotebook(file) {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const data = e.target.result;
                const nb = getNotebookData();

                if (file.type.startsWith('image/')) {
                    // Add image page
                    const img = new Image();
                    img.onload = () => {
                        const newPage = {
                            id: Date.now(),
                            type: 'image',
                            height: Math.min(img.height * (900 / img.width), 1200),
                            strokes: [],
                            content: data
                        };
                        nb.pages.push(newPage);
                        saveNotebook();
                        renderNotebookPages();
                        renderSidebarPages();
                        renderSidebarAttachments();
                    };
                    img.src = data;
                } else if (file.type === 'application/pdf') {
                    // Load PDF and add multi-page
                    try {
                        const base64 = data.replace(/^data:application\/pdf;base64,/, '');
                        const binary = atob(base64);
                        const bytes = new Uint8Array(binary.length);
                        for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);

                        const pdf = await pdfjsLib.getDocument({ data: bytes }).promise;
                        const numPages = pdf.numPages;

                        const newPage = {
                            id: Date.now(),
                            type: 'pdf',
                            height: numPages * 800,
                            strokes: [],
                            pdfData: data,
                            pdfPages: Array.from({ length: numPages }, (_, i) => i),
                            pdfAnnotations: {}
                        };
                        nb.pages.push(newPage);
                        saveNotebook();
                        renderNotebookPages();
                        renderSidebarPages();
                        renderSidebarAttachments();
                    } catch (err) {
                        console.error('PDF load error:', err);
                    }
                }
            };
            reader.readAsDataURL(file);
        }

        // Render sidebar pages
        function renderSidebarPages() {
            const nb = getNotebookData();
            sidebarPagesList.innerHTML = '';

            nb.pages.forEach((page, index) => {
                const item = document.createElement('div');
                item.className = 'sidebar-page-item';
                item.style.display = 'flex';
                item.style.justifyContent = 'space-between';
                item.style.alignItems = 'center';

                // Page info section
                const infoDiv = document.createElement('div');
                infoDiv.style.cursor = 'pointer';
                infoDiv.style.flex = '1';
                infoDiv.innerHTML = `
                    <div class="flex items-center gap-2">
                        <span class="text-lg">${page.type === 'pdf' ? 'ğŸ“„' : page.type === 'image' ? 'ğŸ–¼ï¸' : 'ğŸ“'}</span>
                        <span class="text-sm font-semibold">ØµÙØ­Ø© ${index + 1}</span>
                    </div>
                    <div class="text-xs text-gray-500 mt-1">${page.strokes?.length || 0} Ø±Ø³Ù…</div>
                `;
                infoDiv.addEventListener('click', () => {
                    const offset = nb.pages.slice(0, index).reduce((h, p) => h + p.height, 0);
                    notebookCanvasArea.scrollTo({ top: offset, behavior: 'smooth' });
                });
                item.appendChild(infoDiv);

                // Delete button
                const deleteBtn = document.createElement('button');
                deleteBtn.innerHTML = 'ğŸ—‘ï¸';
                deleteBtn.title = 'Ø­Ø°Ù Ù‡Ø°Ù‡ Ø§Ù„ØµÙØ­Ø©';
                deleteBtn.style.cssText = 'background: #ef4444; color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-size: 14px; display: flex; align-items: center; justify-content: center;';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (confirm(`Ø­Ø°Ù ØµÙØ­Ø© ${index + 1}ØŸ`)) {
                        deleteNotebookPage(index);
                    }
                });
                item.appendChild(deleteBtn);

                sidebarPagesList.appendChild(item);
            });
        }

        // Render sidebar attachments with delete buttons
        function renderSidebarAttachments() {
            const nb = getNotebookData();
            sidebarAttachments.innerHTML = '';

            nb.pages.forEach((page, index) => {
                if (page.type !== 'blank') {
                    const item = document.createElement('div');
                    item.className = 'sidebar-page-item text-sm';
                    item.style.display = 'flex';
                    item.style.justifyContent = 'space-between';
                    item.style.alignItems = 'center';

                    // File info
                    const infoSpan = document.createElement('span');
                    infoSpan.innerHTML = `
                        <span>${page.type === 'pdf' ? 'ğŸ“„ PDF' : 'ğŸ–¼ï¸ ØµÙˆØ±Ø©'}</span>
                        <span class="text-xs text-gray-500 block">ØµÙØ­Ø© ${index + 1}</span>
                    `;
                    item.appendChild(infoSpan);

                    // Delete file button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.innerHTML = 'ğŸ—‘ï¸';
                    deleteBtn.title = 'Ø­Ø°Ù Ù‡Ø°Ø§ Ø§Ù„Ù…Ù„Ù';
                    deleteBtn.style.cssText = 'background: #ef4444; color: white; border: none; border-radius: 50%; width: 26px; height: 26px; cursor: pointer; font-size: 12px; display: flex; align-items: center; justify-content: center;';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const fileType = page.type === 'pdf' ? 'Ù…Ù„Ù PDF' : 'Ø§Ù„ØµÙˆØ±Ø©';
                        if (confirm(`Ø­Ø°Ù ${fileType} ÙƒØ§Ù…Ù„ØŸ`)) {
                            deleteNotebookPage(index);
                        }
                    });
                    item.appendChild(deleteBtn);

                    sidebarAttachments.appendChild(item);
                }
            });

            if (sidebarAttachments.children.length === 0) {
                sidebarAttachments.innerHTML = '<p class="text-xs text-gray-500">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø±ÙÙ‚Ø§Øª</p>';
            }
        }

        // Render notes history in sidebar
        function renderNotesHistory() {
            const historyContainer = document.getElementById('sidebarNotesHistory');
            if (!historyContainer) return;

            historyContainer.innerHTML = '';

            // Get all notes from localStorage
            const allNotes = JSON.parse(localStorage.getItem('notes') || '[]');

            if (allNotes.length === 0) {
                historyContainer.innerHTML = '<p class="text-xs text-gray-500">Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ù„Ø§Ø­Ø¸Ø§Øª Ù…Ø­ÙÙˆØ¸Ø©</p>';
                return;
            }

            // Sort by last modified (newest first)
            const sortedNotes = [...allNotes].sort((a, b) => {
                const dateA = new Date(a.lastModified || a.createdAt || 0);
                const dateB = new Date(b.lastModified || b.createdAt || 0);
                return dateB - dateA;
            });

            sortedNotes.forEach((note, idx) => {
                const item = document.createElement('div');
                item.className = 'sidebar-page-item text-sm cursor-pointer hover:bg-purple-100 transition-all';
                item.style.padding = '8px';
                item.style.borderRadius = '8px';
                item.style.marginBottom = '4px';

                // Format date
                const date = new Date(note.lastModified || note.createdAt);
                const dateStr = date.toLocaleDateString('ar-SA', {
                    month: 'short',
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });

                // Check if note has notebook data
                const hasNotebook = note.notebook && note.notebook.pages && note.notebook.pages.length > 0;
                const pagesCount = hasNotebook ? note.notebook.pages.length : 0;

                item.innerHTML = `
                    <div class="flex items-center gap-2 mb-1">
                        <span class="text-lg">${hasNotebook ? 'ğŸ““' : 'ğŸ“'}</span>
                        <span class="font-semibold text-gray-800 truncate" style="max-width: 120px;">${note.title || 'Ù…Ù„Ø§Ø­Ø¸Ø© ' + (idx + 1)}</span>
                    </div>
                    <div class="text-xs text-gray-500">
                        ${dateStr}
                        ${pagesCount > 0 ? ` â€¢ ${pagesCount} ØµÙØ­Ø©` : ''}
                    </div>
                `;

                // Click to load this note
                item.addEventListener('click', () => {
                    if (note.id) {
                        // Find the task associated with this note
                        const task = tasks.find(t => t.id === note.id);
                        if (task) {
                            // Switch to this note
                            openNotebook(task.id);
                        }
                    }
                });

                historyContainer.appendChild(item);
            });
        }

        // Undo last stroke
        function nbUndo() {
            if (nbStrokesHistory.length === 0) return;
            const last = nbStrokesHistory.pop();
            nbRedoStack.push(last);

            const nb = getNotebookData();
            const page = nb.pages[last.pageIndex];
            if (page.strokes) {
                page.strokes = page.strokes.filter(s => s !== last.stroke);
            }
            saveNotebook();

            // Redraw page
            const canvas = document.querySelector(`canvas[data-page-index="${last.pageIndex}"]`);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                (page.strokes || []).forEach(s => drawNaturalStroke(ctx, s));
            }
        }

        // Redo stroke
        function nbRedo() {
            if (nbRedoStack.length === 0) return;
            const item = nbRedoStack.pop();
            nbStrokesHistory.push(item);

            const nb = getNotebookData();
            const page = nb.pages[item.pageIndex];
            if (!page.strokes) page.strokes = [];
            page.strokes.push(item.stroke);
            saveNotebook();

            const canvas = document.querySelector(`canvas[data-page-index="${item.pageIndex}"]`);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                drawNaturalStroke(ctx, item.stroke);
            }
        }

        // Export notebook
        function exportNotebook() {
            saveNotebook();
            const note = getCurrentNote();
            const exportData = {
                noteId: currentNoteId,
                notebook: note.notebook,
                exportedAt: new Date().toISOString(),
                version: '2.0'
            };

            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `notebook_${currentNoteId}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Setup notebook event listeners
        function setupNotebookEvents() {
            if (openNotebookBtn) openNotebookBtn.addEventListener('click', openNotebook);
            if (closeNotebookBtn) closeNotebookBtn.addEventListener('click', closeNotebook);

            if (nbPenBtn) nbPenBtn.addEventListener('click', () => { nbTool = 'pen'; updateNbToolButtons(); });
            if (nbHighlighterBtn) nbHighlighterBtn.addEventListener('click', () => { nbTool = 'highlighter'; updateNbToolButtons(); });
            if (nbEraserBtn) nbEraserBtn.addEventListener('click', () => { nbTool = 'eraser'; updateNbToolButtons(); });

            if (nbPenThickness) {
                nbPenThickness.addEventListener('input', () => {
                    nbThicknessValue.textContent = nbPenThickness.value + 'px';
                });
            }

            if (nbUndoBtn) nbUndoBtn.addEventListener('click', nbUndo);
            if (nbRedoBtn) nbRedoBtn.addEventListener('click', nbRedo);

            if (nbAddPageBtn) nbAddPageBtn.addEventListener('click', () => addNotebookPage());
            if (nbAddPageSidebar) nbAddPageSidebar.addEventListener('click', () => addNotebookPage());

            if (nbAddFileBtn) nbAddFileBtn.addEventListener('click', () => nbFileInput.click());
            if (nbFileInput) {
                nbFileInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        addFileToNotebook(e.target.files[0]);
                        nbFileInput.value = '';
                    }
                });
            }

            if (nbExportBtn) nbExportBtn.addEventListener('click', exportNotebook);

            if (nbToggleSidebar) {
                nbToggleSidebar.addEventListener('click', () => {
                    notebookSidebar.classList.toggle('collapsed');
                });
            }

            // Sticky notes color picker buttons
            document.querySelectorAll('.nb-sticky-color-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const color = btn.dataset.color;
                    addNotebookSticky(color);
                });
            });

            // Default sticky button (adds yellow sticky)
            const nbAddStickyBtn = document.getElementById('nbAddStickyBtn');
            if (nbAddStickyBtn) {
                nbAddStickyBtn.addEventListener('click', (e) => {
                    // Only add if not clicking color picker
                    if (!e.target.classList.contains('nb-sticky-color-btn')) {
                        addNotebookSticky('yellow');
                    }
                });
            }

            // Save scroll position periodically (NO auto-add pages)
            if (notebookCanvasArea) {
                notebookCanvasArea.addEventListener('scroll', () => {
                    if (notebookOpen) {
                        clearTimeout(window.nbScrollSaveTimeout);
                        window.nbScrollSaveTimeout = setTimeout(saveNotebook, 500);

                        // Show scroll indicator (without auto-adding pages)
                        const indicator = document.getElementById('nbScrollIndicator');
                        if (indicator) {
                            const scrollTop = notebookCanvasArea.scrollTop;
                            const currentPage = Math.floor(scrollTop / 1200) + 1;
                            const nb = getNotebookData();
                            indicator.textContent = `ØµÙØ­Ø© ${currentPage} Ù…Ù† ${nb.pages.length}`;
                            indicator.classList.add('visible');
                            clearTimeout(window.nbScrollIndicatorTimeout);
                            window.nbScrollIndicatorTimeout = setTimeout(() => {
                                indicator.classList.remove('visible');
                            }, 1500);
                        }
                    }
                });
            }

            // Keyboard shortcuts
            document.addEventListener('keydown', (e) => {
                if (!notebookOpen) return;
                if (e.ctrlKey && e.key === 'z') {
                    e.preventDefault();
                    nbUndo();
                } else if (e.ctrlKey && e.key === 'y') {
                    e.preventDefault();
                    nbRedo();
                }
            });
        }

        // ========== NOTEBOOK STICKY NOTES ==========
        let nbStickyZIndex = 100;

        // Add sticky note to notebook
        function addNotebookSticky(colorName = 'yellow') {
            const nb = getNotebookData();
            if (!nb.stickies) nb.stickies = [];

            // Position in visible area
            const scrollTop = notebookCanvasArea ? notebookCanvasArea.scrollTop : 0;
            const viewHeight = notebookCanvasArea ? notebookCanvasArea.clientHeight : 600;

            const newSticky = {
                id: Date.now(),
                color: colorName,
                x: 50 + Math.random() * 200,
                y: scrollTop + 100 + Math.random() * (viewHeight - 300),
                text: '',
                taskId: null, // Can be linked to a task
                createdAt: new Date().toISOString(),
                zIndex: nbStickyZIndex++
            };

            nb.stickies.push(newSticky);
            saveNotebook();
            renderNotebookStickies();
        }

        // Render all notebook sticky notes
        function renderNotebookStickies() {
            const nb = getNotebookData();
            const container = document.getElementById('nbStickiesLayer');
            if (!container) return;

            container.innerHTML = '';
            (nb.stickies || []).forEach((sticky, index) => {
                const el = createNotebookStickyElement(sticky, index);
                container.appendChild(el);
            });
        }

        // Create sticky note element
        function createNotebookStickyElement(sticky, index) {
            const el = document.createElement('div');
            el.className = `nb-sticky-note nb-sticky-${sticky.color}`;
            el.style.left = sticky.x + 'px';
            el.style.top = sticky.y + 'px';
            el.style.zIndex = sticky.zIndex || 50;
            el.dataset.index = index;

            // Get task name if linked
            const linkedTask = sticky.taskId ? tasks.find(t => t.id == sticky.taskId) : null;
            const taskBadge = linkedTask ?
                `<span class="nb-sticky-task-badge" title="${linkedTask.text}">ğŸ”— ${linkedTask.text}</span>` :
                '<span class="nb-sticky-task-badge">ğŸ“Œ Ù…Ù„Ø§Ø­Ø¸Ø© Ø­Ø±Ø©</span>';

            // Build task options
            let taskOptions = '<option value="">-- Ø§Ø®ØªØ± Ù…Ù‡Ù…Ø© --</option>';
            tasks.filter(t => !t.completed).forEach(t => {
                const selected = sticky.taskId == t.id ? 'selected' : '';
                taskOptions += `<option value="${t.id}" ${selected}>${t.text}</option>`;
            });

            el.innerHTML = `
                <div class="nb-sticky-header">
                    ${taskBadge}
                    <div class="nb-sticky-delete" onclick="deleteNotebookSticky(${index})">Ã—</div>
                </div>
                <textarea class="nb-sticky-content" placeholder="Ø§ÙƒØªØ¨ Ù…Ù„Ø§Ø­Ø¸ØªÙƒ Ù‡Ù†Ø§..." 
                    onchange="updateNotebookStickyText(${index}, this.value)">${sticky.text || ''}</textarea>
                <div class="nb-sticky-footer">
                    <select class="nb-sticky-task-select" onchange="updateNotebookStickyTask(${index}, this.value)">
                        ${taskOptions}
                    </select>
                    <span class="nb-sticky-date">${formatArabicDateTime(sticky.createdAt)}</span>
                </div>
            `;

            // Make draggable
            setupStickyDrag(el, index);

            return el;
        }

        // Setup drag behavior for sticky note
        function setupStickyDrag(el, index) {
            let isDragging = false;
            let startX, startY, initialX, initialY;

            const onStart = (e) => {
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'SELECT' ||
                    e.target.classList.contains('nb-sticky-delete')) return;

                isDragging = true;
                el.classList.add('dragging');

                const nb = getNotebookData();
                const sticky = nb.stickies[index];

                startX = e.touches ? e.touches[0].clientX : e.clientX;
                startY = e.touches ? e.touches[0].clientY : e.clientY;
                initialX = sticky.x;
                initialY = sticky.y;

                // Bring to front
                nbStickyZIndex++;
                el.style.zIndex = nbStickyZIndex;
                sticky.zIndex = nbStickyZIndex;
            };

            const onMove = (e) => {
                if (!isDragging) return;
                e.preventDefault();

                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;

                const dx = clientX - startX;
                const dy = clientY - startY;

                const newX = Math.max(0, initialX + dx);
                const newY = Math.max(0, initialY + dy);

                el.style.left = newX + 'px';
                el.style.top = newY + 'px';
            };

            const onEnd = () => {
                if (!isDragging) return;
                isDragging = false;
                el.classList.remove('dragging');

                // Save position
                const nb = getNotebookData();
                const sticky = nb.stickies[index];
                sticky.x = parseInt(el.style.left);
                sticky.y = parseInt(el.style.top);
                saveNotebook();
            };

            el.addEventListener('mousedown', onStart);
            document.addEventListener('mousemove', onMove);
            document.addEventListener('mouseup', onEnd);

            el.addEventListener('touchstart', onStart, { passive: false });
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onEnd);
        }

        // Update sticky note text
        function updateNotebookStickyText(index, text) {
            const nb = getNotebookData();
            if (nb.stickies && nb.stickies[index]) {
                nb.stickies[index].text = text;
                nb.stickies[index].lastModified = new Date().toISOString();
                saveNotebook();
            }
        }

        // Update sticky note task link
        function updateNotebookStickyTask(index, taskId) {
            const nb = getNotebookData();
            if (nb.stickies && nb.stickies[index]) {
                nb.stickies[index].taskId = taskId ? parseInt(taskId) : null;
                saveNotebook();
                renderNotebookStickies(); // Re-render to update badge
            }
        }

        // Delete sticky note
        function deleteNotebookSticky(index) {
            const nb = getNotebookData();
            if (nb.stickies) {
                nb.stickies.splice(index, 1);
                saveNotebook();
                renderNotebookStickies();
            }
        }

        // Make functions global
        window.updateNotebookStickyText = updateNotebookStickyText;
        window.updateNotebookStickyTask = updateNotebookStickyTask;
        window.deleteNotebookSticky = deleteNotebookSticky;

        // Initialize notebook on page load
        setupNotebookEvents();

        // ========== LEGACY NOTES SYSTEM (kept for compatibility) ==========
        // PEN: Strokes stored as { points: [{x,y}], color, width, isEraser, isHighlighter }.
        //      Smoothing via quadratic curves (smoothPoints + quadraticCurveTo). Undo/redo per stroke.
        // PDF: pdf.js loads PDF from Base64; annotations stored in note.pdfAnnotations[attachmentIndex_pageNum].
        //      Each page has its own strokes array; overlay canvas (pdfAnnotationCanvas) draws on top of PDF.
        // PERSIST: LocalStorage key "taskAppNotes". Each note: boardStrokes, boardImages, toolState,
        //          pdfAnnotations, attachments (Base64). Restore on loadCurrentNote() and redrawBoard().

        function loadNotes() {
            const saved = localStorage.getItem('taskAppNotes');
            if (saved) {
                notes = JSON.parse(saved);
            }
        }

        function saveNotes() {
            localStorage.setItem('taskAppNotes', JSON.stringify(notes));
        }

        function getCurrentNote() {
            if (!notes[currentNoteId]) {
                notes[currentNoteId] = {
                    text: '',
                    textColor: '#000000',
                    canvasData: '',
                    boardStrokes: [],
                    boardImages: [],
                    toolState: { penColor: '#000000', penThickness: 5, highlighter: false },
                    stickyNotes: [],
                    attachments: [],
                    pdfAnnotations: {},
                    passwordHash: null,
                    locked: false,
                    lastModified: new Date().toISOString()
                };
            }
            return notes[currentNoteId];
        }

        function updateNoteTaskSelector() {
            noteTaskSelector.innerHTML = '<option value="global">Ù…Ù„Ø§Ø­Ø¸Ø© Ø¹Ø§Ù…Ø©</option>';
            tasks.forEach(task => {
                if (!task.completed) {
                    const option = document.createElement('option');
                    option.value = `task_${task.id}`;
                    option.textContent = task.text;
                    noteTaskSelector.appendChild(option);
                }
            });
            // Also include completed tasks for their notes
            tasks.filter(t => t.completed).forEach(task => {
                const option = document.createElement('option');
                option.value = `task_${task.id}`;
                option.textContent = `${task.text} (Ù…ÙƒØªÙ…Ù„Ø©)`;
                noteTaskSelector.appendChild(option);
            });
        }

        function formatArabicDateTime(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('ar-SA', {
                year: 'numeric',
                month: 'long',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function simpleHash(password) {
            let hash = 0;
            for (let i = 0; i < password.length; i++) {
                const char = password.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return hash.toString();
        }

        function checkNoteLock() {
            const note = getCurrentNote();
            if (note.locked && note.passwordHash) {
                noteContent.style.display = 'none';
                passwordModal.classList.remove('hidden');
                noteLockStatus.textContent = 'ğŸ”’ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© Ù…Ù‚ÙÙ„Ø©';
                lockNoteBtn.textContent = 'ğŸ”“ ÙØªØ­ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©';
                return true;
            } else {
                noteContent.style.display = 'block';
                passwordModal.classList.add('hidden');
                noteLockStatus.textContent = note.locked ? 'ğŸ”’ Ù…Ù‚ÙÙ„Ø©' : 'ğŸ”“ ØºÙŠØ± Ù…Ù‚ÙÙ„Ø©';
                lockNoteBtn.textContent = note.locked ? 'ğŸ”“ ÙØªØ­ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©' : 'ğŸ”’ Ù‚ÙÙ„ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©';
                return false;
            }
        }

        function loadCurrentNote() {
            const note = getCurrentNote();
            if (checkNoteLock()) return;

            // If notebook is open, refresh it
            if (notebookOpen) {
                renderNotebookPages();
                renderSidebarPages();
                renderSidebarAttachments();
            }
        }

        function saveCurrentNote() {
            const note = getCurrentNote();
            note.lastModified = new Date().toISOString();
            saveNotes();
        }

        // ----- Board: stroke smoothing (quadratic curves) -----
        function smoothPoints(points) {
            if (points.length < 3) return points;
            const smoothed = [points[0]];
            for (let i = 1; i < points.length - 1; i++) {
                const midX = (points[i].x + points[i + 1].x) / 2;
                const midY = (points[i].y + points[i + 1].y) / 2;
                smoothed.push({ x: midX, y: midY });
            }
            smoothed.push(points[points.length - 1]);
            return smoothed;
        }

        function drawStroke(ctx, stroke) {
            const pts = stroke.points || [];
            if (pts.length < 2) return;
            const smoothed = smoothPoints(pts);
            ctx.beginPath();
            ctx.moveTo(smoothed[0].x, smoothed[0].y);
            for (let i = 1; i < smoothed.length - 1; i++) {
                const xc = (smoothed[i].x + smoothed[i + 1].x) / 2;
                const yc = (smoothed[i].y + smoothed[i + 1].y) / 2;
                ctx.quadraticCurveTo(smoothed[i].x, smoothed[i].y, xc, yc);
            }
            ctx.lineTo(smoothed[smoothed.length - 1].x, smoothed[smoothed.length - 1].y);
            ctx.stroke();
        }

        function applyBoardToolState() {
            const ctx = drawingCanvas.getContext('2d');
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.lineWidth = parseInt(penThickness.value);
            ctx.strokeStyle = penColor.value;
            if (isEraser) {
                ctx.globalCompositeOperation = 'destination-out';
                ctx.strokeStyle = 'rgba(0,0,0,1)';
            } else if (isHighlighter) {
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 0.4;
                ctx.strokeStyle = penColor.value;
            } else {
                ctx.globalCompositeOperation = 'source-over';
                ctx.globalAlpha = 1;
                ctx.strokeStyle = penColor.value;
            }
        }

        function redrawBoard() {
            const ctx = drawingCanvas.getContext('2d');
            const w = drawingCanvas.width;
            const h = drawingCanvas.height;
            ctx.clearRect(0, 0, w, h);
            const note = getCurrentNote();
            const images = note.boardImages || [];
            let drawn = 0;
            images.forEach((imgObj, idx) => {
                const img = new Image();
                img.onload = () => {
                    ctx.save();
                    ctx.translate(imgObj.x + imgObj.width / 2, imgObj.y + imgObj.height / 2);
                    ctx.rotate((imgObj.rotation || 0) * Math.PI / 180);
                    ctx.translate(-imgObj.width / 2, -imgObj.height / 2);
                    ctx.drawImage(img, 0, 0, imgObj.width, imgObj.height);
                    ctx.restore();
                    drawn++;
                    if (drawn === images.length) drawAllStrokes(ctx);
                };
                img.src = imgObj.data;
            });
            if (images.length === 0) drawAllStrokes(ctx);
        }

        function drawAllStrokes(ctx) {
            const strokesToDraw = currentStroke ? [...boardStrokes, currentStroke] : boardStrokes;
            strokesToDraw.forEach(s => {
                ctx.save();
                if (s.isEraser) { ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = '#000'; ctx.lineWidth = s.width || 5; }
                else if (s.isHighlighter) { ctx.globalAlpha = 0.4; ctx.strokeStyle = s.color || '#ffff00'; ctx.lineWidth = s.width || 15; }
                else { ctx.strokeStyle = s.color || '#000'; ctx.lineWidth = s.width || 5; }
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                drawStroke(ctx, s);
                ctx.restore();
            });
        }

        function renderBoardImages() {
            const note = getCurrentNote();
            const images = note.boardImages || [];
            const existing = boardWrapper.querySelectorAll('.board-image-object');
            existing.forEach(el => el.remove());
            images.forEach((imgObj, index) => {
                const div = document.createElement('div');
                div.className = 'board-image-object';
                div.dataset.index = index;
                div.style.left = imgObj.x + 'px';
                div.style.top = imgObj.y + 'px';
                div.style.width = imgObj.width + 'px';
                div.style.height = imgObj.height + 'px';
                div.style.transform = 'rotate(' + (imgObj.rotation || 0) + 'deg)';
                const img = document.createElement('img');
                img.src = imgObj.data;
                img.style.width = '100%';
                img.style.height = '100%';
                img.style.pointerEvents = 'none';
                img.draggable = false;
                div.appendChild(img);
                const resizeHandle = document.createElement('div');
                resizeHandle.className = 'resize-handle';
                div.appendChild(resizeHandle);
                const rotateHandle = document.createElement('div');
                rotateHandle.className = 'rotate-handle';
                div.appendChild(rotateHandle);
                boardWrapper.appendChild(div);
                setupBoardImageHandlers(div, index);
            });
        }

        function setupBoardImageHandlers(div, index) {
            const note = getCurrentNote();
            const imgObj = note.boardImages[index];
            if (!imgObj) return;
            let dragStart = null, resizeStart = null, rotateStart = null;
            div.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('resize-handle')) {
                    resizeStart = { x: e.clientX, y: e.clientY, w: imgObj.width, h: imgObj.height };
                } else if (e.target.classList.contains('rotate-handle')) {
                    rotateStart = { x: e.clientX, angle: imgObj.rotation || 0 };
                } else {
                    dragStart = { x: e.clientX - imgObj.x, y: e.clientY - imgObj.y };
                    div.classList.add('selected');
                }
            });
            document.addEventListener('mousemove', (e) => {
                if (resizeStart) {
                    const dw = e.clientX - resizeStart.x;
                    const dh = e.clientY - resizeStart.y;
                    imgObj.width = Math.max(50, resizeStart.w + dw);
                    imgObj.height = Math.max(50, resizeStart.h + dh);
                    div.style.width = imgObj.width + 'px';
                    div.style.height = imgObj.height + 'px';
                } else if (rotateStart) {
                    const rect = div.getBoundingClientRect();
                    const cx = rect.left + rect.width / 2;
                    const cy = rect.top + rect.height / 2;
                    const a = Math.atan2(e.clientY - cy, e.clientX - cx);
                    const a0 = Math.atan2(0, 1);
                    imgObj.rotation = rotateStart.angle + (a - a0) * 180 / Math.PI;
                    div.style.transform = 'rotate(' + imgObj.rotation + 'deg)';
                } else if (dragStart) {
                    const nx = e.clientX - dragStart.x;
                    const ny = e.clientY - dragStart.y;
                    const bw = boardWrapper.offsetWidth;
                    const bh = 400;
                    imgObj.x = Math.max(0, Math.min(bw - imgObj.width, nx));
                    imgObj.y = Math.max(0, Math.min(bh - imgObj.height, ny));
                    div.style.left = imgObj.x + 'px';
                    div.style.top = imgObj.y + 'px';
                }
            });
            document.addEventListener('mouseup', () => {
                if (resizeStart || rotateStart || dragStart) {
                    resizeStart = null;
                    rotateStart = null;
                    dragStart = null;
                    div.classList.remove('selected');
                    redrawBoard();
                    saveBoardToNote();
                }
            });
        }

        function getBoardCanvasCoords(e) {
            const rect = drawingCanvas.getBoundingClientRect();
            const scaleX = drawingCanvas.width / rect.width;
            const scaleY = drawingCanvas.height / rect.height;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        function initCanvas() {
            const resizeBoard = () => {
                const w = boardWrapper.offsetWidth;
                const h = 400;
                drawingCanvas.width = w;
                drawingCanvas.height = h;
                drawingCanvas.style.width = w + 'px';
                drawingCanvas.style.height = h + 'px';
                redrawBoard();
            };
            resizeBoard();
            window.addEventListener('resize', resizeBoard);

            drawingCanvas.addEventListener('mousedown', (e) => {
                if (e.target !== drawingCanvas) return;
                const coords = getBoardCanvasCoords(e);
                currentStroke = {
                    points: [{ x: coords.x, y: coords.y }],
                    color: penColor.value,
                    width: parseInt(penThickness.value),
                    isEraser: isEraser,
                    isHighlighter: isHighlighter
                };
                isDrawing = true;
            });
            drawingCanvas.addEventListener('mousemove', (e) => {
                if (!isDrawing || !currentStroke) return;
                const coords = getBoardCanvasCoords(e);
                currentStroke.points.push({ x: coords.x, y: coords.y });
                redrawBoard();
                const ctx = drawingCanvas.getContext('2d');
                applyBoardToolState();
                drawStroke(ctx, currentStroke);
            });
            drawingCanvas.addEventListener('mouseup', () => {
                if (isDrawing && currentStroke && currentStroke.points.length > 1) {
                    boardStrokesRedoStack = [];
                    boardStrokes.push(currentStroke);
                    currentStroke = null;
                    isDrawing = false;
                    redrawBoard();
                    updateUndoRedoButtons();
                    saveBoardToNote();
                } else {
                    currentStroke = null;
                    isDrawing = false;
                }
            });
            drawingCanvas.addEventListener('mouseout', () => {
                if (isDrawing && currentStroke && currentStroke.points.length > 1) {
                    boardStrokesRedoStack = [];
                    boardStrokes.push(currentStroke);
                    currentStroke = null;
                    isDrawing = false;
                    redrawBoard();
                    updateUndoRedoButtons();
                    saveBoardToNote();
                } else {
                    currentStroke = null;
                    isDrawing = false;
                }
            });

            drawingCanvas.addEventListener('touchstart', (e) => { e.preventDefault(); }, { passive: false });
            drawingCanvas.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive: false });
            drawingCanvas.addEventListener('touchend', (e) => { e.preventDefault(); }, { passive: false });

            document.addEventListener('keydown', (e) => {
                if (e.ctrlKey && e.key === 'v') {
                    e.preventDefault();
                    if (e.clipboardData) handlePasteImage(e);
                }
            });
            document.addEventListener('paste', (e) => {
                if (currentPage === 'notes' && noteContent.style.display !== 'none' && boardWrapper.contains(document.activeElement) || document.activeElement === document.body) {
                    if (e.clipboardData && e.clipboardData.items) {
                        for (let i = 0; i < e.clipboardData.items.length; i++) {
                            if (e.clipboardData.items[i].type.indexOf('image') !== -1) {
                                e.preventDefault();
                                const file = e.clipboardData.items[i].getAsFile();
                                const reader = new FileReader();
                                reader.onload = (ev) => addBoardImage(ev.target.result);
                                reader.readAsDataURL(file);
                                return;
                            }
                        }
                    }
                }
            });
            boardWrapper.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
            boardWrapper.addEventListener('drop', (e) => {
                e.preventDefault();
                const file = e.dataTransfer.files[0];
                if (file && file.type.startsWith('image/')) {
                    const reader = new FileReader();
                    reader.onload = (ev) => addBoardImage(ev.target.result);
                    reader.readAsDataURL(file);
                }
            });

            updateUndoRedoButtons();
        }

        function handlePasteImage(e) {
            const items = (e.clipboardData || window.clipboardData).items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    const file = items[i].getAsFile();
                    const reader = new FileReader();
                    reader.onload = (ev) => addBoardImage(ev.target.result);
                    reader.readAsDataURL(file);
                    return;
                }
            }
        }

        function addBoardImage(dataUrl) {
            const note = getCurrentNote();
            if (!note.boardImages) note.boardImages = [];
            const img = new Image();
            img.onload = () => {
                const maxW = Math.min(300, boardWrapper.offsetWidth - 40);
                const maxH = 250;
                let w = img.width, h = img.height;
                if (w > maxW || h > maxH) {
                    const r = Math.min(maxW / w, maxH / h);
                    w = Math.round(w * r);
                    h = Math.round(h * r);
                }
                const x = Math.max(0, (boardWrapper.offsetWidth - w) / 2);
                const y = Math.max(0, (400 - h) / 2);
                note.boardImages.push({ id: Date.now(), data: dataUrl, x, y, width: w, height: h, rotation: 0 });
                renderBoardImages();
                redrawBoard();
                saveBoardToNote();
            };
            img.src = dataUrl;
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = boardStrokes.length === 0;
            redoBtn.disabled = boardStrokesRedoStack.length === 0;
        }

        function saveBoardToNote() {
            const note = getCurrentNote();
            note.boardStrokes = JSON.parse(JSON.stringify(boardStrokes));
            note.boardImages = note.boardImages || [];
            note.toolState = {
                penColor: penColor.value,
                penThickness: parseInt(penThickness.value),
                highlighter: isHighlighter
            };
            note.canvasData = drawingCanvas.toDataURL();
            note.canvasLastModified = new Date().toISOString();
            canvasLastModified.textContent = formatArabicDateTime(note.canvasLastModified);
            saveCurrentNote();
        }

        function undoCanvas() {
            if (boardStrokes.length > 0) {
                boardStrokesRedoStack.push(boardStrokes.pop());
                redrawBoard();
                updateUndoRedoButtons();
                saveBoardToNote();
            }
        }

        function redoCanvas() {
            if (boardStrokesRedoStack.length > 0) {
                boardStrokes.push(boardStrokesRedoStack.pop());
                redrawBoard();
                updateUndoRedoButtons();
                saveBoardToNote();
            }
        }

        function clearCanvas() {
            if (confirm('Ù‡Ù„ Ø£Ù†Øª Ù…ØªØ£ÙƒØ¯ Ù…Ù† Ù…Ø³Ø­ Ø§Ù„Ø±Ø³Ù… ÙˆØ§Ù„ØµÙˆØ±ØŸ')) {
                const note = getCurrentNote();
                note.boardStrokes = [];
                note.boardImages = [];
                boardStrokes = [];
                boardStrokesRedoStack = [];
                redrawBoard();
                renderBoardImages();
                updateUndoRedoButtons();
                saveBoardToNote();
            }
        }

        // Sticky Notes Functions
        function renderStickyNotes() {
            const note = getCurrentNote();
            stickyNotesContainer.innerHTML = '';
            note.stickyNotes = note.stickyNotes || [];
            note.stickyNotes.forEach((sticky, index) => {
                createStickyNoteElement(sticky, index);
            });
        }

        function createStickyNoteElement(sticky, index) {
            const stickyEl = document.createElement('div');
            stickyEl.className = 'sticky-note absolute cursor-move p-3 rounded-lg shadow-lg';
            stickyEl.style.backgroundColor = sticky.color;
            stickyEl.style.left = sticky.x + 'px';
            stickyEl.style.top = sticky.y + 'px';
            stickyEl.style.width = '200px';
            stickyEl.style.zIndex = sticky.zIndex || stickyNoteZIndex++;
            stickyEl.style.minHeight = '150px';
            stickyEl.innerHTML = `
                <div class="flex justify-between items-start mb-2">
                    <span class="text-xs text-gray-600">${formatArabicDateTime(sticky.createdAt)}</span>
                    <button onclick="deleteStickyNote(${index})" class="text-red-600 hover:text-red-800 font-bold">Ã—</button>
                </div>
                <textarea class="w-full bg-transparent border-none resize-none focus:outline-none text-sm" style="min-height: 100px;" onchange="updateStickyNote(${index}, this.value)">${sticky.text || ''}</textarea>
            `;

            // Make draggable
            let isDragging = false;
            let currentX, currentY, initialX, initialY;

            stickyEl.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON' || e.target.tagName === 'TEXTAREA') return;
                isDragging = true;
                initialX = e.clientX - sticky.x;
                initialY = e.clientY - sticky.y;
                stickyEl.style.zIndex = stickyNoteZIndex++;
            });

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                currentX = e.clientX - initialX;
                currentY = e.clientY - initialY;
                stickyEl.style.left = currentX + 'px';
                stickyEl.style.top = currentY + 'px';
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    const note = getCurrentNote();
                    note.stickyNotes[index].x = currentX;
                    note.stickyNotes[index].y = currentY;
                    note.stickyNotes[index].zIndex = parseInt(stickyEl.style.zIndex);
                    saveCurrentNote();
                }
            });

            stickyNotesContainer.appendChild(stickyEl);
        }

        function addStickyNote() {
            const note = getCurrentNote();
            if (!note.stickyNotes) note.stickyNotes = [];
            const rect = stickyNotesContainer.getBoundingClientRect();
            note.stickyNotes.push({
                text: '',
                color: stickyColor.value,
                x: Math.random() * (rect.width - 200),
                y: Math.random() * (rect.height - 150),
                zIndex: stickyNoteZIndex++,
                createdAt: new Date().toISOString()
            });
            renderStickyNotes();
            saveCurrentNote();
        }

        function updateStickyNote(index, text) {
            const note = getCurrentNote();
            if (note.stickyNotes[index]) {
                note.stickyNotes[index].text = text;
                note.stickyNotes[index].lastModified = new Date().toISOString();
                saveCurrentNote();
            }
        }

        function deleteStickyNote(index) {
            const note = getCurrentNote();
            note.stickyNotes.splice(index, 1);
            renderStickyNotes();
            saveCurrentNote();
        }

        // File Attachments Functions
        function renderAttachments() {
            const note = getCurrentNote();
            attachmentsContainer.innerHTML = '';
            note.attachments = note.attachments || [];
            note.attachments.forEach((attachment, index) => {
                const attachEl = document.createElement('div');
                attachEl.className = 'bg-white rounded-lg p-4 border-2 border-purple-300';
                attachEl.innerHTML = `
                    <div class="flex justify-between items-start mb-2">
                        <span class="font-semibold text-gray-800">${attachment.name}</span>
                        <button onclick="deleteAttachment(${index})" class="text-red-600 hover:text-red-800 font-bold">ğŸ—‘ï¸</button>
                    </div>
                    <div class="mb-2">
                        ${attachment.type.startsWith('image/') ?
                        `<div class="relative inline-block"><img src="${attachment.data}" class="max-w-full h-auto rounded-lg" alt="${attachment.name}"><canvas id="img-annot-${index}" class="absolute left-0 top-0 w-full h-full rounded-lg pointer-events-none" style="max-width:100%;max-height:300px;"></canvas></div>` :
                        attachment.type === 'application/pdf' ?
                            `<div><button type="button" onclick="openPdfViewer(${index})" class="px-3 py-2 rounded-lg bg-purple-500 text-white font-bold hover:opacity-80 mb-2">ğŸ“„ Ø¹Ø±Ø¶ PDF ÙˆØ§Ù„ÙƒØªØ§Ø¨Ø© Ø¹Ù„ÙŠÙ‡</button><canvas id="pdf-canvas-${index}" class="border rounded-lg"></canvas></div>` :
                            `<p class="text-gray-600">Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù: ${attachment.type}</p>`
                    }
                    </div>
                    <textarea placeholder="Ø£Ø¶Ù ØªØ¹Ù„ÙŠÙ‚..." class="w-full px-3 py-2 rounded-lg border-2 border-purple-300 text-sm" onchange="updateAttachmentComment(${index}, this.value)">${attachment.comment || ''}</textarea>
                    <div class="text-xs text-gray-500 mt-2">ØªÙ… Ø§Ù„Ø±ÙØ¹: ${formatArabicDateTime(attachment.uploadedAt)}</div>
                `;
                attachmentsContainer.appendChild(attachEl);

                if (attachment.type === 'application/pdf') {
                    renderPDFPage(attachment.data, `pdf-canvas-${index}`);
                }
            });
        }

        function renderPDFPage(base64Data, canvasId) {
            // Simple PDF rendering - show first page as image if possible
            // Note: Full PDF rendering requires PDF.js library, but we'll show a placeholder
            const canvas = document.getElementById(canvasId);
            if (canvas) {
                const ctx = canvas.getContext('2d');
                canvas.width = 600;
                canvas.height = 800;
                ctx.fillStyle = '#f0f0f0';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#333';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('PDF - Ø§Ù„ØµÙØ­Ø© Ø§Ù„Ø£ÙˆÙ„Ù‰', canvas.width / 2, canvas.height / 2);
                ctx.fillText('(ÙŠØªØ·Ù„Ø¨ Ù…ÙƒØªØ¨Ø© PDF.js Ù„Ù„Ø¹Ø±Ø¶ Ø§Ù„ÙƒØ§Ù…Ù„)', canvas.width / 2, canvas.height / 2 + 30);
            }
        }

        function handleFileAttachment(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const note = getCurrentNote();
                if (!note.attachments) note.attachments = [];
                note.attachments.push({
                    name: file.name,
                    type: file.type,
                    data: e.target.result,
                    comment: '',
                    uploadedAt: new Date().toISOString()
                });
                renderAttachments();
                saveCurrentNote();
            };
            if (file.type.startsWith('image/')) {
                reader.readAsDataURL(file);
            } else if (file.type === 'application/pdf') {
                reader.readAsDataURL(file);
            } else {
                alert('Ù†ÙˆØ¹ Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…Ø¯Ø¹ÙˆÙ…. ÙŠØ±Ø¬Ù‰ Ø§Ø®ØªÙŠØ§Ø± ØµÙˆØ±Ø© Ø£Ùˆ PDF');
            }
        }

        function updateAttachmentComment(index, comment) {
            const note = getCurrentNote();
            if (note.attachments[index]) {
                note.attachments[index].comment = comment;
                saveCurrentNote();
            }
        }

        function deleteAttachment(index) {
            const note = getCurrentNote();
            note.attachments.splice(index, 1);
            renderAttachments();
            saveCurrentNote();
        }

        // Export/Import Functions
        function exportNoteAsJSON() {
            saveBoardToNote();
            const note = getCurrentNote();
            const exportData = {
                noteId: currentNoteId,
                text: note.text,
                textColor: note.textColor,
                canvasData: note.canvasData,
                boardStrokes: note.boardStrokes,
                boardImages: note.boardImages,
                toolState: note.toolState,
                stickyNotes: note.stickyNotes,
                attachments: note.attachments,
                pdfAnnotations: note.pdfAnnotations,
                exportedAt: new Date().toISOString()
            };
            const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `note_${currentNoteId}_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function exportNoteAsPNG() {
            saveBoardToNote();
            const note = getCurrentNote();
            const outCanvas = document.createElement('canvas');
            const w = 1200;
            const h = 1600;
            outCanvas.width = w;
            outCanvas.height = h;
            const ctx = outCanvas.getContext('2d');
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, w, h);
            let y = 50;
            ctx.fillStyle = note.textColor || '#000000';
            ctx.font = '24px Arial';
            (note.text || '').split('\n').forEach(line => { ctx.fillText(line, 50, y); y += 30; });
            y += 30;
            const boardData = drawingCanvas.toDataURL();
            if (boardData && boardData !== 'data:,') {
                const boardImg = new Image();
                boardImg.onload = () => {
                    ctx.drawImage(boardImg, 50, y, 1100, 450);
                    y += 480;
                    (note.stickyNotes || []).forEach(sticky => {
                        ctx.fillStyle = sticky.color;
                        ctx.fillRect(50, y, 200, 150);
                        ctx.fillStyle = '#000000';
                        ctx.globalAlpha = 1;
                        ctx.font = '16px Arial';
                        (sticky.text || '').split('\n').forEach((line, i) => { ctx.fillText(line, 60, y + 20 + (i * 20)); });
                        y += 170;
                    });
                    outCanvas.toBlob((blob) => {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `note_${currentNoteId}_${Date.now()}.png`;
                        a.click();
                        URL.revokeObjectURL(url);
                    });
                };
                boardImg.src = boardData;
            } else {
                (note.stickyNotes || []).forEach(sticky => {
                    ctx.fillStyle = sticky.color;
                    ctx.fillRect(50, y, 200, 150);
                    ctx.fillStyle = '#000000';
                    ctx.globalAlpha = 1;
                    ctx.font = '16px Arial';
                    (sticky.text || '').split('\n').forEach((line, i) => { ctx.fillText(line, 60, y + 20 + (i * 20)); });
                    y += 170;
                });
                outCanvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `note_${currentNoteId}_${Date.now()}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }
        }

        function importNote(file) {
            if (file.type === 'application/json') {
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const importData = JSON.parse(e.target.result);
                        const note = getCurrentNote();
                        if (importData.text !== undefined) note.text = importData.text;
                        if (importData.textColor) note.textColor = importData.textColor;
                        if (importData.canvasData) note.canvasData = importData.canvasData;
                        if (importData.boardStrokes) note.boardStrokes = importData.boardStrokes;
                        if (importData.boardImages) note.boardImages = importData.boardImages;
                        if (importData.toolState) note.toolState = importData.toolState;
                        if (importData.stickyNotes) note.stickyNotes = importData.stickyNotes;
                        if (importData.attachments) note.attachments = importData.attachments;
                        if (importData.pdfAnnotations) note.pdfAnnotations = importData.pdfAnnotations;
                        loadCurrentNote();
                        alert('ØªÙ… Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø© Ø¨Ù†Ø¬Ø§Ø­!');
                    } catch (err) {
                        alert('Ø®Ø·Ø£ ÙÙŠ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ø§Ù„Ù…Ù„Ù: ' + err.message);
                    }
                };
                reader.readAsText(file);
            } else {
                alert('ÙŠØ±Ø¬Ù‰ Ø§Ø³ØªÙŠØ±Ø§Ø¯ Ù…Ù„Ù JSON ØµØ§Ù„Ø­');
            }
        }

        // Event Listeners for Notes
        noteTaskSelector.addEventListener('change', () => {
            saveCurrentNote();
            currentNoteId = noteTaskSelector.value;
            loadCurrentNote();
        });

        lockNoteBtn.addEventListener('click', () => {
            const note = getCurrentNote();
            if (note.locked) {
                // Unlock
                passwordInput.value = '';
                passwordModal.classList.remove('hidden');
            } else {
                // Lock - set password
                const password = prompt('Ø£Ø¯Ø®Ù„ ÙƒÙ„Ù…Ø© Ù…Ø±ÙˆØ± Ù„Ù‚ÙÙ„ Ù‡Ø°Ù‡ Ø§Ù„Ù…Ù„Ø§Ø­Ø¸Ø©:');
                if (password) {
                    note.passwordHash = simpleHash(password);
                    note.locked = true;
                    checkNoteLock();
                    saveCurrentNote();
                }
            }
        });

        passwordSubmit.addEventListener('click', () => {
            const note = getCurrentNote();
            const enteredHash = simpleHash(passwordInput.value);
            if (enteredHash === note.passwordHash) {
                note.locked = false;
                passwordInput.value = '';
                checkNoteLock();
                saveCurrentNote();
            } else {
                alert('ÙƒÙ„Ù…Ø© Ø§Ù„Ù…Ø±ÙˆØ± ØºÙŠØ± ØµØ­ÙŠØ­Ø©!');
                passwordInput.value = '';
            }
        });

        passwordCancel.addEventListener('click', () => {
            passwordInput.value = '';
            passwordModal.classList.add('hidden');
        });

        passwordInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                passwordSubmit.click();
            }
        });

        // Canvas controls
        penThickness.addEventListener('input', () => {
            thicknessValue.textContent = penThickness.value + 'px';
            const ctx = drawingCanvas.getContext('2d');
            ctx.lineWidth = parseInt(penThickness.value);
        });

        penColor.addEventListener('change', () => {
            const ctx = drawingCanvas.getContext('2d');
            ctx.strokeStyle = penColor.value;
            isEraser = false;
            currentTool = 'pen';
        });

        function updateToolButtonStates() {
            penBtn.classList.toggle('tool-btn-active', currentTool === 'pen');
            highlighterBtn.classList.toggle('tool-btn-active', currentTool === 'highlighter');
            eraserBtn.classList.toggle('tool-btn-active', currentTool === 'eraser');
        }

        penBtn.addEventListener('click', () => {
            const ctx = drawingCanvas.getContext('2d');
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 1;
            ctx.strokeStyle = penColor.value;
            isEraser = false;
            isHighlighter = false;
            currentTool = 'pen';
            updateToolButtonStates();
        });

        highlighterBtn.addEventListener('click', () => {
            const ctx = drawingCanvas.getContext('2d');
            ctx.globalCompositeOperation = 'source-over';
            ctx.globalAlpha = 0.4;
            ctx.strokeStyle = penColor.value;
            isEraser = false;
            isHighlighter = true;
            currentTool = 'highlighter';
            updateToolButtonStates();
        });

        eraserBtn.addEventListener('click', () => {
            const ctx = drawingCanvas.getContext('2d');
            ctx.globalCompositeOperation = 'destination-out';
            isEraser = true;
            isHighlighter = false;
            currentTool = 'eraser';
            updateToolButtonStates();
        });

        undoBtn.addEventListener('click', undoCanvas);
        redoBtn.addEventListener('click', redoCanvas);
        clearCanvasBtn.addEventListener('click', clearCanvas);

        // Text notes
        textColor.addEventListener('change', () => {
            textNotes.style.color = textColor.value;
            const note = getCurrentNote();
            note.textColor = textColor.value;
            saveCurrentNote();
        });

        textNotes.addEventListener('input', () => {
            const note = getCurrentNote();
            note.text = textNotes.value;
            note.textLastModified = new Date().toISOString();
            textLastModified.textContent = formatArabicDateTime(note.textLastModified);
            saveCurrentNote();
        });

        // Sticky notes
        addStickyBtn.addEventListener('click', addStickyNote);

        // File attachments
        attachFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                handleFileAttachment(e.target.files[0]);
                fileInput.value = '';
            }
        });

        // Export/Import
        exportJSONBtn.addEventListener('click', exportNoteAsJSON);
        exportPNGBtn.addEventListener('click', exportNoteAsPNG);
        importBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                importNote(e.target.files[0]);
                importFileInput.value = '';
            }
        });

        // Make functions global for inline event handlers
        window.deleteStickyNote = deleteStickyNote;
        window.updateStickyNote = updateStickyNote;
        window.deleteAttachment = deleteAttachment;
        window.updateAttachmentComment = updateAttachmentComment;

        // PDF.js worker (encapsulated - does not affect rest of app)
        if (typeof pdfjsLib !== 'undefined') {
            try {
                pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdn.jsdelivr.net/npm/pdfjs-dist@3.11.174/build/pdf.worker.min.js';
            } catch (err) { }
        }

        async function openPdfViewer(attachmentIndex) {
            const note = getCurrentNote();
            const att = note.attachments && note.attachments[attachmentIndex];
            if (!att || att.type !== 'application/pdf') return;
            currentPdfAttachmentIndex = attachmentIndex;
            pdfViewerSection.classList.remove('hidden');
            const base64 = att.data.replace(/^data:application\/pdf;base64,/, '');
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            try {
                pdfDoc = await pdfjsLib.getDocument({ data: bytes }).promise;
                pdfTotalPages = pdfDoc.numPages;
                pdfCurrentPage = 1;
                pdfPageIndicator.textContent = 'ØµÙØ­Ø© 1 Ù…Ù† ' + pdfTotalPages;
                await renderPdfPage();
                loadPdfAnnotations();
            } catch (err) {
                console.error('PDF load error', err);
                pdfViewerSection.classList.add('hidden');
            }
        }

        async function renderPdfPage() {
            if (!pdfDoc) return;
            const page = await pdfDoc.getPage(pdfCurrentPage);
            const viewport = page.getViewport({ scale: pdfScale });
            pdfCanvas.width = viewport.width;
            pdfCanvas.height = viewport.height;
            pdfAnnotationCanvas.width = viewport.width;
            pdfAnnotationCanvas.height = viewport.height;
            pdfAnnotationCanvas.style.width = viewport.width + 'px';
            pdfAnnotationCanvas.style.height = viewport.height + 'px';
            const ctx = pdfCanvas.getContext('2d');
            await page.render({ canvasContext: ctx, viewport: viewport }).promise;
            pdfPageIndicator.textContent = 'ØµÙØ­Ø© ' + pdfCurrentPage + ' Ù…Ù† ' + pdfTotalPages;
            redrawPdfAnnotations();
        }

        function getPdfAnnotationKey() {
            return currentPdfAttachmentIndex + '_' + pdfCurrentPage;
        }

        function loadPdfAnnotations() {
            const note = getCurrentNote();
            note.pdfAnnotations = note.pdfAnnotations || {};
            const key = getPdfAnnotationKey();
            pdfAnnotationStrokes = (note.pdfAnnotations[key] || []).map(s => ({ ...s, points: s.points || [] }));
            redrawPdfAnnotations();
        }

        function savePdfAnnotations() {
            const note = getCurrentNote();
            note.pdfAnnotations = note.pdfAnnotations || {};
            note.pdfAnnotations[getPdfAnnotationKey()] = JSON.parse(JSON.stringify(pdfAnnotationStrokes));
            saveCurrentNote();
        }

        function redrawPdfAnnotations() {
            const ctx = pdfAnnotationCanvas.getContext('2d');
            ctx.clearRect(0, 0, pdfAnnotationCanvas.width, pdfAnnotationCanvas.height);
            pdfAnnotationStrokes.forEach(s => {
                ctx.save();
                if (s.isEraser) { ctx.globalCompositeOperation = 'destination-out'; ctx.strokeStyle = '#000'; ctx.lineWidth = s.width || 5; }
                else if (s.isHighlighter) { ctx.globalAlpha = 0.4; ctx.strokeStyle = s.color || '#ffff00'; ctx.lineWidth = s.width || 15; }
                else { ctx.strokeStyle = s.color || '#000'; ctx.lineWidth = s.width || 5; }
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                drawStroke(ctx, s);
                ctx.restore();
            });
        }

        function setupPdfAnnotationCanvas() {
            const getCoords = (e) => {
                const rect = pdfAnnotationCanvas.getBoundingClientRect();
                const scaleX = pdfAnnotationCanvas.width / rect.width;
                const scaleY = pdfAnnotationCanvas.height / rect.height;
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
            };
            pdfAnnotationCanvas.addEventListener('mousedown', (e) => {
                if (!pdfAnnotating) return;
                const coords = getCoords(e);
                pdfAnnotationCurrentStroke = { points: [coords], color: penColor.value, width: parseInt(penThickness.value), isEraser: isEraser, isHighlighter: isHighlighter };
            });
            pdfAnnotationCanvas.addEventListener('mousemove', (e) => {
                if (!pdfAnnotating || !pdfAnnotationCurrentStroke) return;
                const coords = getCoords(e);
                pdfAnnotationCurrentStroke.points.push(coords);
                redrawPdfAnnotations();
                const ctx = pdfAnnotationCanvas.getContext('2d');
                ctx.save();
                if (pdfAnnotationCurrentStroke.isHighlighter) ctx.globalAlpha = 0.4;
                ctx.strokeStyle = pdfAnnotationCurrentStroke.color;
                ctx.lineWidth = pdfAnnotationCurrentStroke.width;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                drawStroke(ctx, pdfAnnotationCurrentStroke);
                ctx.restore();
            });
            pdfAnnotationCanvas.addEventListener('mouseup', () => {
                if (pdfAnnotating && pdfAnnotationCurrentStroke && pdfAnnotationCurrentStroke.points.length > 1) {
                    pdfAnnotationStrokes.push(pdfAnnotationCurrentStroke);
                    pdfAnnotationCurrentStroke = null;
                    savePdfAnnotations();
                }
            });
            pdfAnnotationCanvas.addEventListener('mouseout', () => {
                if (pdfAnnotating && pdfAnnotationCurrentStroke && pdfAnnotationCurrentStroke.points.length > 1) {
                    pdfAnnotationStrokes.push(pdfAnnotationCurrentStroke);
                    pdfAnnotationCurrentStroke = null;
                    savePdfAnnotations();
                }
            });
        }

        pdfPrevPage.addEventListener('click', async () => {
            if (pdfCurrentPage <= 1) return;
            savePdfAnnotations();
            pdfCurrentPage--;
            await renderPdfPage();
            loadPdfAnnotations();
        });
        pdfNextPage.addEventListener('click', async () => {
            if (pdfCurrentPage >= pdfTotalPages) return;
            savePdfAnnotations();
            pdfCurrentPage++;
            await renderPdfPage();
            loadPdfAnnotations();
        });
        pdfZoomIn.addEventListener('click', () => { pdfScale += 0.2; renderPdfPage(); });
        pdfZoomOut.addEventListener('click', () => { pdfScale = Math.max(0.5, pdfScale - 0.2); renderPdfPage(); });
        pdfAnnotateBtn.addEventListener('click', () => {
            pdfAnnotating = !pdfAnnotating;
            pdfAnnotationCanvas.classList.toggle('active', pdfAnnotating);
            pdfAnnotateBtn.textContent = pdfAnnotating ? 'âœï¸ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø±Ø³Ù…' : 'âœï¸ Ø±Ø³Ù… Ø¹Ù„Ù‰ Ø§Ù„ØµÙØ­Ø©';
        });
        setupPdfAnnotationCanvas();

        // Initialize Notes System
        loadNotes();
        initCanvas();
        updateToolButtonStates();

        // ========== END NOTES SYSTEM ==========

        loadTasks();
        addBtn.addEventListener('click', addTask);
        taskInput.addEventListener('keypress', e => { if (e.key === 'Enter') addTask(); });
        darkModeBtn.addEventListener('click', toggleDarkMode);
        todayTab.addEventListener('click', () => switchPage('today'));
        calendarTab.addEventListener('click', () => switchPage('calendar'));
        historyTab.addEventListener('click', () => switchPage('history'));
        notesTab.addEventListener('click', () => switchPage('notes'));
        showAllHistory.addEventListener('click', () => renderHistory('all'));
        showWeekHistory.addEventListener('click', () => renderHistory('week'));
        showMonthHistory.addEventListener('click', () => renderHistory('month'));
        renderTodayTasks();
        switchPage('today');
    </script>
</body>

</html>

